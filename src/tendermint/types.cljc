;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package tendermint.types
;;;----------------------------------------------------------------------------------
(ns tendermint.types
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [tendermint.types :as tendermint.types]
            [tendermint.version :as tendermint.version]
            [tendermint.crypto :as tendermint.crypto]
            [com.google.protobuf :as com.google.protobuf]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->ValidatorParams)
(declare ecis->ValidatorParams)
(declare new-ValidatorParams)
(declare cis->ConsensusParams)
(declare ecis->ConsensusParams)
(declare new-ConsensusParams)
(declare cis->Vote)
(declare ecis->Vote)
(declare new-Vote)
(declare cis->Header)
(declare ecis->Header)
(declare new-Header)
(declare cis->BlockID)
(declare ecis->BlockID)
(declare new-BlockID)
(declare cis->CommitSig)
(declare ecis->CommitSig)
(declare new-CommitSig)
(declare cis->DuplicateVoteEvidence)
(declare ecis->DuplicateVoteEvidence)
(declare new-DuplicateVoteEvidence)
(declare cis->BlockMeta)
(declare ecis->BlockMeta)
(declare new-BlockMeta)
(declare cis->Evidence)
(declare ecis->Evidence)
(declare new-Evidence)
(declare cis->Block)
(declare ecis->Block)
(declare new-Block)
(declare cis->Commit)
(declare ecis->Commit)
(declare new-Commit)
(declare cis->Proposal)
(declare ecis->Proposal)
(declare new-Proposal)
(declare cis->EvidenceList)
(declare ecis->EvidenceList)
(declare new-EvidenceList)
(declare cis->HashedParams)
(declare ecis->HashedParams)
(declare new-HashedParams)
(declare cis->EvidenceParams)
(declare ecis->EvidenceParams)
(declare new-EvidenceParams)
(declare cis->SignedHeader)
(declare ecis->SignedHeader)
(declare new-SignedHeader)
(declare cis->SimpleValidator)
(declare ecis->SimpleValidator)
(declare new-SimpleValidator)
(declare cis->Part)
(declare ecis->Part)
(declare new-Part)
(declare cis->PartSetHeader)
(declare ecis->PartSetHeader)
(declare new-PartSetHeader)
(declare cis->Data)
(declare ecis->Data)
(declare new-Data)
(declare cis->VersionParams)
(declare ecis->VersionParams)
(declare new-VersionParams)
(declare cis->ValidatorSet)
(declare ecis->ValidatorSet)
(declare new-ValidatorSet)
(declare cis->TxProof)
(declare ecis->TxProof)
(declare new-TxProof)
(declare cis->LightBlock)
(declare ecis->LightBlock)
(declare new-LightBlock)
(declare cis->LightClientAttackEvidence)
(declare ecis->LightClientAttackEvidence)
(declare new-LightClientAttackEvidence)
(declare cis->BlockParams)
(declare ecis->BlockParams)
(declare new-BlockParams)
(declare cis->Validator)
(declare ecis->Validator)
(declare new-Validator)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; BlockIDFlag
;-----------------------------------------------------------------------------
(def BlockIDFlag-default :block-id-flag-unknown)

(def BlockIDFlag-val2label {
  0 :block-id-flag-unknown
  1 :block-id-flag-absent
  2 :block-id-flag-commit
  3 :block-id-flag-nil})

(def BlockIDFlag-label2val (set/map-invert BlockIDFlag-val2label))

(defn cis->BlockIDFlag [is]
  (let [val (serdes.core/cis->Enum is)]
    (get BlockIDFlag-val2label val val)))

(defn- get-BlockIDFlag [value]
  {:pre [(or (int? value) (contains? BlockIDFlag-label2val value))]}
  (get BlockIDFlag-label2val value value))

(defn write-BlockIDFlag
  ([tag value os] (write-BlockIDFlag tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-BlockIDFlag value) os)))

;-----------------------------------------------------------------------------
; SignedMsgType
;-----------------------------------------------------------------------------
(def SignedMsgType-default :signed-msg-type-unknown)

(def SignedMsgType-val2label {
  0 :signed-msg-type-unknown
  1 :signed-msg-type-prevote
  2 :signed-msg-type-precommit
  32 :signed-msg-type-proposal})

(def SignedMsgType-label2val (set/map-invert SignedMsgType-val2label))

(defn cis->SignedMsgType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get SignedMsgType-val2label val val)))

(defn- get-SignedMsgType [value]
  {:pre [(or (int? value) (contains? SignedMsgType-label2val value))]}
  (get SignedMsgType-label2val value value))

(defn write-SignedMsgType
  ([tag value os] (write-SignedMsgType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-SignedMsgType value) os)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Evidence-sum's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Evidence-sum [origkeyval]
  (cond
     (get-in origkeyval [:sum :duplicate-vote-evidence]) (update-in origkeyval [:sum :duplicate-vote-evidence] new-DuplicateVoteEvidence)
     (get-in origkeyval [:sum :light-client-attack-evidence]) (update-in origkeyval [:sum :light-client-attack-evidence] new-LightClientAttackEvidence)
     :default origkeyval))

(defn write-Evidence-sum [sum os]
  (let [field (first sum)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :duplicate-vote-evidence (serdes.core/write-embedded 1 v os)
         :light-client-attack-evidence (serdes.core/write-embedded 2 v os)
         nil)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; ValidatorParams
;-----------------------------------------------------------------------------
(defrecord ValidatorParams-record [pub-key-types]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-String 1 (:pub-key-types this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.ValidatorParams"))

(s/def :tendermint.types.ValidatorParams/pub-key-types (s/every string?))
(s/def ::ValidatorParams-spec (s/keys :opt-un [:tendermint.types.ValidatorParams/pub-key-types ]))
(def ValidatorParams-defaults {:pub-key-types [] })

(defn cis->ValidatorParams
  "CodedInputStream to ValidatorParams"
  [is]
  (->> (tag-map ValidatorParams-defaults
         (fn [tag index]
             (case index
               1 [:pub-key-types (serdes.complex/cis->repeated serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ValidatorParams-record)))

(defn ecis->ValidatorParams
  "Embedded CodedInputStream to ValidatorParams"
  [is]
  (serdes.core/cis->embedded cis->ValidatorParams is))

(defn new-ValidatorParams
  "Creates a new instance from a map, similar to map->ValidatorParams except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ValidatorParams-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ValidatorParams-spec init))))]}
  (-> (merge ValidatorParams-defaults init)
      (map->ValidatorParams-record)))

(defn pb->ValidatorParams
  "Protobuf to ValidatorParams"
  [input]
  (cis->ValidatorParams (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ValidatorParams-meta {:type "tendermint.types.ValidatorParams" :decoder pb->ValidatorParams})

;-----------------------------------------------------------------------------
; ConsensusParams
;-----------------------------------------------------------------------------
(defrecord ConsensusParams-record [block evidence validator version]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:block this) os)
    (serdes.core/write-embedded 2 (:evidence this) os)
    (serdes.core/write-embedded 3 (:validator this) os)
    (serdes.core/write-embedded 4 (:version this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.ConsensusParams"))

(s/def ::ConsensusParams-spec (s/keys :opt-un []))
(def ConsensusParams-defaults {})

(defn cis->ConsensusParams
  "CodedInputStream to ConsensusParams"
  [is]
  (->> (tag-map ConsensusParams-defaults
         (fn [tag index]
             (case index
               1 [:block (ecis->BlockParams is)]
               2 [:evidence (ecis->EvidenceParams is)]
               3 [:validator (ecis->ValidatorParams is)]
               4 [:version (ecis->VersionParams is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ConsensusParams-record)))

(defn ecis->ConsensusParams
  "Embedded CodedInputStream to ConsensusParams"
  [is]
  (serdes.core/cis->embedded cis->ConsensusParams is))

(defn new-ConsensusParams
  "Creates a new instance from a map, similar to map->ConsensusParams except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ConsensusParams-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ConsensusParams-spec init))))]}
  (-> (merge ConsensusParams-defaults init)
      (cond-> (some? (get init :block)) (update :block new-BlockParams))
      (cond-> (some? (get init :evidence)) (update :evidence new-EvidenceParams))
      (cond-> (some? (get init :validator)) (update :validator new-ValidatorParams))
      (cond-> (some? (get init :version)) (update :version new-VersionParams))
      (map->ConsensusParams-record)))

(defn pb->ConsensusParams
  "Protobuf to ConsensusParams"
  [input]
  (cis->ConsensusParams (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ConsensusParams-meta {:type "tendermint.types.ConsensusParams" :decoder pb->ConsensusParams})

;-----------------------------------------------------------------------------
; Vote
;-----------------------------------------------------------------------------
(defrecord Vote-record [type height round block-id timestamp validator-address validator-index signature]
  pb/Writer
  (serialize [this os]
    (write-SignedMsgType 1  {:optimize true} (:type this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:height this) os)
    (serdes.core/write-Int32 3  {:optimize true} (:round this) os)
    (serdes.core/write-embedded 4 (:block-id this) os)
    (serdes.core/write-embedded 5 (:timestamp this) os)
    (serdes.core/write-Bytes 6  {:optimize true} (:validator-address this) os)
    (serdes.core/write-Int32 7  {:optimize true} (:validator-index this) os)
    (serdes.core/write-Bytes 8  {:optimize true} (:signature this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.Vote"))

(s/def :tendermint.types.Vote/type (s/or :keyword keyword? :int int?))
(s/def :tendermint.types.Vote/height int?)
(s/def :tendermint.types.Vote/round int?)


(s/def :tendermint.types.Vote/validator-address bytes?)
(s/def :tendermint.types.Vote/validator-index int?)
(s/def :tendermint.types.Vote/signature bytes?)
(s/def ::Vote-spec (s/keys :opt-un [:tendermint.types.Vote/type :tendermint.types.Vote/height :tendermint.types.Vote/round :tendermint.types.Vote/validator-address :tendermint.types.Vote/validator-index :tendermint.types.Vote/signature ]))
(def Vote-defaults {:type SignedMsgType-default :height 0 :round 0 :validator-address (byte-array 0) :validator-index 0 :signature (byte-array 0) })

(defn cis->Vote
  "CodedInputStream to Vote"
  [is]
  (->> (tag-map Vote-defaults
         (fn [tag index]
             (case index
               1 [:type (cis->SignedMsgType is)]
               2 [:height (serdes.core/cis->Int64 is)]
               3 [:round (serdes.core/cis->Int32 is)]
               4 [:block-id (ecis->BlockID is)]
               5 [:timestamp (com.google.protobuf/ecis->Timestamp is)]
               6 [:validator-address (serdes.core/cis->Bytes is)]
               7 [:validator-index (serdes.core/cis->Int32 is)]
               8 [:signature (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Vote-record)))

(defn ecis->Vote
  "Embedded CodedInputStream to Vote"
  [is]
  (serdes.core/cis->embedded cis->Vote is))

(defn new-Vote
  "Creates a new instance from a map, similar to map->Vote except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Vote-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Vote-spec init))))]}
  (-> (merge Vote-defaults init)
      (cond-> (some? (get init :block-id)) (update :block-id new-BlockID))
      (cond-> (some? (get init :timestamp)) (update :timestamp com.google.protobuf/new-Timestamp))
      (map->Vote-record)))

(defn pb->Vote
  "Protobuf to Vote"
  [input]
  (cis->Vote (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Vote-meta {:type "tendermint.types.Vote" :decoder pb->Vote})

;-----------------------------------------------------------------------------
; Header
;-----------------------------------------------------------------------------
(defrecord Header-record [last-commit-hash height proposer-address app-hash validators-hash evidence-hash time chain-id next-validators-hash version last-block-id data-hash last-results-hash consensus-hash]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 6  {:optimize true} (:last-commit-hash this) os)
    (serdes.core/write-Int64 3  {:optimize true} (:height this) os)
    (serdes.core/write-Bytes 14  {:optimize true} (:proposer-address this) os)
    (serdes.core/write-Bytes 11  {:optimize true} (:app-hash this) os)
    (serdes.core/write-Bytes 8  {:optimize true} (:validators-hash this) os)
    (serdes.core/write-Bytes 13  {:optimize true} (:evidence-hash this) os)
    (serdes.core/write-embedded 4 (:time this) os)
    (serdes.core/write-String 2  {:optimize true} (:chain-id this) os)
    (serdes.core/write-Bytes 9  {:optimize true} (:next-validators-hash this) os)
    (serdes.core/write-embedded 1 (:version this) os)
    (serdes.core/write-embedded 5 (:last-block-id this) os)
    (serdes.core/write-Bytes 7  {:optimize true} (:data-hash this) os)
    (serdes.core/write-Bytes 12  {:optimize true} (:last-results-hash this) os)
    (serdes.core/write-Bytes 10  {:optimize true} (:consensus-hash this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.Header"))

(s/def :tendermint.types.Header/last-commit-hash bytes?)
(s/def :tendermint.types.Header/height int?)
(s/def :tendermint.types.Header/proposer-address bytes?)
(s/def :tendermint.types.Header/app-hash bytes?)
(s/def :tendermint.types.Header/validators-hash bytes?)
(s/def :tendermint.types.Header/evidence-hash bytes?)

(s/def :tendermint.types.Header/chain-id string?)
(s/def :tendermint.types.Header/next-validators-hash bytes?)


(s/def :tendermint.types.Header/data-hash bytes?)
(s/def :tendermint.types.Header/last-results-hash bytes?)
(s/def :tendermint.types.Header/consensus-hash bytes?)
(s/def ::Header-spec (s/keys :opt-un [:tendermint.types.Header/last-commit-hash :tendermint.types.Header/height :tendermint.types.Header/proposer-address :tendermint.types.Header/app-hash :tendermint.types.Header/validators-hash :tendermint.types.Header/evidence-hash :tendermint.types.Header/chain-id :tendermint.types.Header/next-validators-hash :tendermint.types.Header/data-hash :tendermint.types.Header/last-results-hash :tendermint.types.Header/consensus-hash ]))
(def Header-defaults {:last-commit-hash (byte-array 0) :height 0 :proposer-address (byte-array 0) :app-hash (byte-array 0) :validators-hash (byte-array 0) :evidence-hash (byte-array 0) :chain-id "" :next-validators-hash (byte-array 0) :data-hash (byte-array 0) :last-results-hash (byte-array 0) :consensus-hash (byte-array 0) })

(defn cis->Header
  "CodedInputStream to Header"
  [is]
  (->> (tag-map Header-defaults
         (fn [tag index]
             (case index
               6 [:last-commit-hash (serdes.core/cis->Bytes is)]
               3 [:height (serdes.core/cis->Int64 is)]
               14 [:proposer-address (serdes.core/cis->Bytes is)]
               11 [:app-hash (serdes.core/cis->Bytes is)]
               8 [:validators-hash (serdes.core/cis->Bytes is)]
               13 [:evidence-hash (serdes.core/cis->Bytes is)]
               4 [:time (com.google.protobuf/ecis->Timestamp is)]
               2 [:chain-id (serdes.core/cis->String is)]
               9 [:next-validators-hash (serdes.core/cis->Bytes is)]
               1 [:version (tendermint.version/ecis->Consensus is)]
               5 [:last-block-id (ecis->BlockID is)]
               7 [:data-hash (serdes.core/cis->Bytes is)]
               12 [:last-results-hash (serdes.core/cis->Bytes is)]
               10 [:consensus-hash (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Header-record)))

(defn ecis->Header
  "Embedded CodedInputStream to Header"
  [is]
  (serdes.core/cis->embedded cis->Header is))

(defn new-Header
  "Creates a new instance from a map, similar to map->Header except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Header-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Header-spec init))))]}
  (-> (merge Header-defaults init)
      (cond-> (some? (get init :version)) (update :version tendermint.version/new-Consensus))
      (cond-> (some? (get init :time)) (update :time com.google.protobuf/new-Timestamp))
      (cond-> (some? (get init :last-block-id)) (update :last-block-id new-BlockID))
      (map->Header-record)))

(defn pb->Header
  "Protobuf to Header"
  [input]
  (cis->Header (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Header-meta {:type "tendermint.types.Header" :decoder pb->Header})

;-----------------------------------------------------------------------------
; BlockID
;-----------------------------------------------------------------------------
(defrecord BlockID-record [hash part-set-header]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:hash this) os)
    (serdes.core/write-embedded 2 (:part-set-header this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.BlockID"))

(s/def :tendermint.types.BlockID/hash bytes?)

(s/def ::BlockID-spec (s/keys :opt-un [:tendermint.types.BlockID/hash ]))
(def BlockID-defaults {:hash (byte-array 0) })

(defn cis->BlockID
  "CodedInputStream to BlockID"
  [is]
  (->> (tag-map BlockID-defaults
         (fn [tag index]
             (case index
               1 [:hash (serdes.core/cis->Bytes is)]
               2 [:part-set-header (ecis->PartSetHeader is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BlockID-record)))

(defn ecis->BlockID
  "Embedded CodedInputStream to BlockID"
  [is]
  (serdes.core/cis->embedded cis->BlockID is))

(defn new-BlockID
  "Creates a new instance from a map, similar to map->BlockID except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BlockID-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BlockID-spec init))))]}
  (-> (merge BlockID-defaults init)
      (cond-> (some? (get init :part-set-header)) (update :part-set-header new-PartSetHeader))
      (map->BlockID-record)))

(defn pb->BlockID
  "Protobuf to BlockID"
  [input]
  (cis->BlockID (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BlockID-meta {:type "tendermint.types.BlockID" :decoder pb->BlockID})

;-----------------------------------------------------------------------------
; CommitSig
;-----------------------------------------------------------------------------
(defrecord CommitSig-record [block-id-flag validator-address timestamp signature]
  pb/Writer
  (serialize [this os]
    (write-BlockIDFlag 1  {:optimize true} (:block-id-flag this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:validator-address this) os)
    (serdes.core/write-embedded 3 (:timestamp this) os)
    (serdes.core/write-Bytes 4  {:optimize true} (:signature this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.CommitSig"))

(s/def :tendermint.types.CommitSig/block-id-flag (s/or :keyword keyword? :int int?))
(s/def :tendermint.types.CommitSig/validator-address bytes?)

(s/def :tendermint.types.CommitSig/signature bytes?)
(s/def ::CommitSig-spec (s/keys :opt-un [:tendermint.types.CommitSig/block-id-flag :tendermint.types.CommitSig/validator-address :tendermint.types.CommitSig/signature ]))
(def CommitSig-defaults {:block-id-flag BlockIDFlag-default :validator-address (byte-array 0) :signature (byte-array 0) })

(defn cis->CommitSig
  "CodedInputStream to CommitSig"
  [is]
  (->> (tag-map CommitSig-defaults
         (fn [tag index]
             (case index
               1 [:block-id-flag (cis->BlockIDFlag is)]
               2 [:validator-address (serdes.core/cis->Bytes is)]
               3 [:timestamp (com.google.protobuf/ecis->Timestamp is)]
               4 [:signature (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->CommitSig-record)))

(defn ecis->CommitSig
  "Embedded CodedInputStream to CommitSig"
  [is]
  (serdes.core/cis->embedded cis->CommitSig is))

(defn new-CommitSig
  "Creates a new instance from a map, similar to map->CommitSig except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::CommitSig-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::CommitSig-spec init))))]}
  (-> (merge CommitSig-defaults init)
      (cond-> (some? (get init :timestamp)) (update :timestamp com.google.protobuf/new-Timestamp))
      (map->CommitSig-record)))

(defn pb->CommitSig
  "Protobuf to CommitSig"
  [input]
  (cis->CommitSig (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record CommitSig-meta {:type "tendermint.types.CommitSig" :decoder pb->CommitSig})

;-----------------------------------------------------------------------------
; DuplicateVoteEvidence
;-----------------------------------------------------------------------------
(defrecord DuplicateVoteEvidence-record [vote-a vote-b total-voting-power validator-power timestamp]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:vote-a this) os)
    (serdes.core/write-embedded 2 (:vote-b this) os)
    (serdes.core/write-Int64 3  {:optimize true} (:total-voting-power this) os)
    (serdes.core/write-Int64 4  {:optimize true} (:validator-power this) os)
    (serdes.core/write-embedded 5 (:timestamp this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.DuplicateVoteEvidence"))

(s/def :tendermint.types.DuplicateVoteEvidence/total-voting-power int?)
(s/def :tendermint.types.DuplicateVoteEvidence/validator-power int?)

(s/def ::DuplicateVoteEvidence-spec (s/keys :opt-un [:tendermint.types.DuplicateVoteEvidence/total-voting-power :tendermint.types.DuplicateVoteEvidence/validator-power ]))
(def DuplicateVoteEvidence-defaults {:total-voting-power 0 :validator-power 0 })

(defn cis->DuplicateVoteEvidence
  "CodedInputStream to DuplicateVoteEvidence"
  [is]
  (->> (tag-map DuplicateVoteEvidence-defaults
         (fn [tag index]
             (case index
               1 [:vote-a (ecis->Vote is)]
               2 [:vote-b (ecis->Vote is)]
               3 [:total-voting-power (serdes.core/cis->Int64 is)]
               4 [:validator-power (serdes.core/cis->Int64 is)]
               5 [:timestamp (com.google.protobuf/ecis->Timestamp is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->DuplicateVoteEvidence-record)))

(defn ecis->DuplicateVoteEvidence
  "Embedded CodedInputStream to DuplicateVoteEvidence"
  [is]
  (serdes.core/cis->embedded cis->DuplicateVoteEvidence is))

(defn new-DuplicateVoteEvidence
  "Creates a new instance from a map, similar to map->DuplicateVoteEvidence except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DuplicateVoteEvidence-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DuplicateVoteEvidence-spec init))))]}
  (-> (merge DuplicateVoteEvidence-defaults init)
      (cond-> (some? (get init :vote-a)) (update :vote-a new-Vote))
      (cond-> (some? (get init :vote-b)) (update :vote-b new-Vote))
      (cond-> (some? (get init :timestamp)) (update :timestamp com.google.protobuf/new-Timestamp))
      (map->DuplicateVoteEvidence-record)))

(defn pb->DuplicateVoteEvidence
  "Protobuf to DuplicateVoteEvidence"
  [input]
  (cis->DuplicateVoteEvidence (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record DuplicateVoteEvidence-meta {:type "tendermint.types.DuplicateVoteEvidence" :decoder pb->DuplicateVoteEvidence})

;-----------------------------------------------------------------------------
; BlockMeta
;-----------------------------------------------------------------------------
(defrecord BlockMeta-record [block-id block-size header num-txs]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:block-id this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:block-size this) os)
    (serdes.core/write-embedded 3 (:header this) os)
    (serdes.core/write-Int64 4  {:optimize true} (:num-txs this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.BlockMeta"))

(s/def :tendermint.types.BlockMeta/block-size int?)

(s/def :tendermint.types.BlockMeta/num-txs int?)
(s/def ::BlockMeta-spec (s/keys :opt-un [:tendermint.types.BlockMeta/block-size :tendermint.types.BlockMeta/num-txs ]))
(def BlockMeta-defaults {:block-size 0 :num-txs 0 })

(defn cis->BlockMeta
  "CodedInputStream to BlockMeta"
  [is]
  (->> (tag-map BlockMeta-defaults
         (fn [tag index]
             (case index
               1 [:block-id (ecis->BlockID is)]
               2 [:block-size (serdes.core/cis->Int64 is)]
               3 [:header (ecis->Header is)]
               4 [:num-txs (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BlockMeta-record)))

(defn ecis->BlockMeta
  "Embedded CodedInputStream to BlockMeta"
  [is]
  (serdes.core/cis->embedded cis->BlockMeta is))

(defn new-BlockMeta
  "Creates a new instance from a map, similar to map->BlockMeta except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BlockMeta-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BlockMeta-spec init))))]}
  (-> (merge BlockMeta-defaults init)
      (cond-> (some? (get init :block-id)) (update :block-id new-BlockID))
      (cond-> (some? (get init :header)) (update :header new-Header))
      (map->BlockMeta-record)))

(defn pb->BlockMeta
  "Protobuf to BlockMeta"
  [input]
  (cis->BlockMeta (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BlockMeta-meta {:type "tendermint.types.BlockMeta" :decoder pb->BlockMeta})

;-----------------------------------------------------------------------------
; Evidence
;-----------------------------------------------------------------------------
(defrecord Evidence-record [sum]
  pb/Writer
  (serialize [this os]
    (write-Evidence-sum  (:sum this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.Evidence"))

(s/def ::Evidence-spec (s/keys :opt-un []))
(def Evidence-defaults {})

(defn cis->Evidence
  "CodedInputStream to Evidence"
  [is]
  (->> (tag-map Evidence-defaults
         (fn [tag index]
             (case index
               1 [:sum {:duplicate-vote-evidence (ecis->DuplicateVoteEvidence is)}]
               2 [:sum {:light-client-attack-evidence (ecis->LightClientAttackEvidence is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Evidence-record)))

(defn ecis->Evidence
  "Embedded CodedInputStream to Evidence"
  [is]
  (serdes.core/cis->embedded cis->Evidence is))

(defn new-Evidence
  "Creates a new instance from a map, similar to map->Evidence except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Evidence-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Evidence-spec init))))]}
  (-> (merge Evidence-defaults init)
      (convert-Evidence-sum)
      (map->Evidence-record)))

(defn pb->Evidence
  "Protobuf to Evidence"
  [input]
  (cis->Evidence (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Evidence-meta {:type "tendermint.types.Evidence" :decoder pb->Evidence})

;-----------------------------------------------------------------------------
; Block
;-----------------------------------------------------------------------------
(defrecord Block-record [header data evidence last-commit]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:header this) os)
    (serdes.core/write-embedded 2 (:data this) os)
    (serdes.core/write-embedded 3 (:evidence this) os)
    (serdes.core/write-embedded 4 (:last-commit this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.Block"))

(s/def ::Block-spec (s/keys :opt-un []))
(def Block-defaults {})

(defn cis->Block
  "CodedInputStream to Block"
  [is]
  (->> (tag-map Block-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->Header is)]
               2 [:data (ecis->Data is)]
               3 [:evidence (ecis->EvidenceList is)]
               4 [:last-commit (ecis->Commit is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Block-record)))

(defn ecis->Block
  "Embedded CodedInputStream to Block"
  [is]
  (serdes.core/cis->embedded cis->Block is))

(defn new-Block
  "Creates a new instance from a map, similar to map->Block except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Block-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Block-spec init))))]}
  (-> (merge Block-defaults init)
      (cond-> (some? (get init :header)) (update :header new-Header))
      (cond-> (some? (get init :data)) (update :data new-Data))
      (cond-> (some? (get init :evidence)) (update :evidence new-EvidenceList))
      (cond-> (some? (get init :last-commit)) (update :last-commit new-Commit))
      (map->Block-record)))

(defn pb->Block
  "Protobuf to Block"
  [input]
  (cis->Block (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Block-meta {:type "tendermint.types.Block" :decoder pb->Block})

;-----------------------------------------------------------------------------
; Commit
;-----------------------------------------------------------------------------
(defrecord Commit-record [height round block-id signatures]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int64 1  {:optimize true} (:height this) os)
    (serdes.core/write-Int32 2  {:optimize true} (:round this) os)
    (serdes.core/write-embedded 3 (:block-id this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:signatures this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.Commit"))

(s/def :tendermint.types.Commit/height int?)
(s/def :tendermint.types.Commit/round int?)


(s/def ::Commit-spec (s/keys :opt-un [:tendermint.types.Commit/height :tendermint.types.Commit/round ]))
(def Commit-defaults {:height 0 :round 0 :signatures [] })

(defn cis->Commit
  "CodedInputStream to Commit"
  [is]
  (->> (tag-map Commit-defaults
         (fn [tag index]
             (case index
               1 [:height (serdes.core/cis->Int64 is)]
               2 [:round (serdes.core/cis->Int32 is)]
               3 [:block-id (ecis->BlockID is)]
               4 [:signatures (serdes.complex/cis->repeated ecis->CommitSig is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Commit-record)))

(defn ecis->Commit
  "Embedded CodedInputStream to Commit"
  [is]
  (serdes.core/cis->embedded cis->Commit is))

(defn new-Commit
  "Creates a new instance from a map, similar to map->Commit except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Commit-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Commit-spec init))))]}
  (-> (merge Commit-defaults init)
      (cond-> (some? (get init :block-id)) (update :block-id new-BlockID))
      (cond-> (some? (get init :signatures)) (update :signatures #(map new-CommitSig %)))
      (map->Commit-record)))

(defn pb->Commit
  "Protobuf to Commit"
  [input]
  (cis->Commit (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Commit-meta {:type "tendermint.types.Commit" :decoder pb->Commit})

;-----------------------------------------------------------------------------
; Proposal
;-----------------------------------------------------------------------------
(defrecord Proposal-record [type height round pol-round block-id timestamp signature]
  pb/Writer
  (serialize [this os]
    (write-SignedMsgType 1  {:optimize true} (:type this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:height this) os)
    (serdes.core/write-Int32 3  {:optimize true} (:round this) os)
    (serdes.core/write-Int32 4  {:optimize true} (:pol-round this) os)
    (serdes.core/write-embedded 5 (:block-id this) os)
    (serdes.core/write-embedded 6 (:timestamp this) os)
    (serdes.core/write-Bytes 7  {:optimize true} (:signature this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.Proposal"))

(s/def :tendermint.types.Proposal/type (s/or :keyword keyword? :int int?))
(s/def :tendermint.types.Proposal/height int?)
(s/def :tendermint.types.Proposal/round int?)
(s/def :tendermint.types.Proposal/pol-round int?)


(s/def :tendermint.types.Proposal/signature bytes?)
(s/def ::Proposal-spec (s/keys :opt-un [:tendermint.types.Proposal/type :tendermint.types.Proposal/height :tendermint.types.Proposal/round :tendermint.types.Proposal/pol-round :tendermint.types.Proposal/signature ]))
(def Proposal-defaults {:type SignedMsgType-default :height 0 :round 0 :pol-round 0 :signature (byte-array 0) })

(defn cis->Proposal
  "CodedInputStream to Proposal"
  [is]
  (->> (tag-map Proposal-defaults
         (fn [tag index]
             (case index
               1 [:type (cis->SignedMsgType is)]
               2 [:height (serdes.core/cis->Int64 is)]
               3 [:round (serdes.core/cis->Int32 is)]
               4 [:pol-round (serdes.core/cis->Int32 is)]
               5 [:block-id (ecis->BlockID is)]
               6 [:timestamp (com.google.protobuf/ecis->Timestamp is)]
               7 [:signature (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Proposal-record)))

(defn ecis->Proposal
  "Embedded CodedInputStream to Proposal"
  [is]
  (serdes.core/cis->embedded cis->Proposal is))

(defn new-Proposal
  "Creates a new instance from a map, similar to map->Proposal except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Proposal-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Proposal-spec init))))]}
  (-> (merge Proposal-defaults init)
      (cond-> (some? (get init :block-id)) (update :block-id new-BlockID))
      (cond-> (some? (get init :timestamp)) (update :timestamp com.google.protobuf/new-Timestamp))
      (map->Proposal-record)))

(defn pb->Proposal
  "Protobuf to Proposal"
  [input]
  (cis->Proposal (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Proposal-meta {:type "tendermint.types.Proposal" :decoder pb->Proposal})

;-----------------------------------------------------------------------------
; EvidenceList
;-----------------------------------------------------------------------------
(defrecord EvidenceList-record [evidence]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:evidence this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.EvidenceList"))

(s/def ::EvidenceList-spec (s/keys :opt-un []))
(def EvidenceList-defaults {:evidence [] })

(defn cis->EvidenceList
  "CodedInputStream to EvidenceList"
  [is]
  (->> (tag-map EvidenceList-defaults
         (fn [tag index]
             (case index
               1 [:evidence (serdes.complex/cis->repeated ecis->Evidence is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->EvidenceList-record)))

(defn ecis->EvidenceList
  "Embedded CodedInputStream to EvidenceList"
  [is]
  (serdes.core/cis->embedded cis->EvidenceList is))

(defn new-EvidenceList
  "Creates a new instance from a map, similar to map->EvidenceList except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EvidenceList-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EvidenceList-spec init))))]}
  (-> (merge EvidenceList-defaults init)
      (cond-> (some? (get init :evidence)) (update :evidence #(map new-Evidence %)))
      (map->EvidenceList-record)))

(defn pb->EvidenceList
  "Protobuf to EvidenceList"
  [input]
  (cis->EvidenceList (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EvidenceList-meta {:type "tendermint.types.EvidenceList" :decoder pb->EvidenceList})

;-----------------------------------------------------------------------------
; HashedParams
;-----------------------------------------------------------------------------
(defrecord HashedParams-record [block-max-bytes block-max-gas]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int64 1  {:optimize true} (:block-max-bytes this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:block-max-gas this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.HashedParams"))

(s/def :tendermint.types.HashedParams/block-max-bytes int?)
(s/def :tendermint.types.HashedParams/block-max-gas int?)
(s/def ::HashedParams-spec (s/keys :opt-un [:tendermint.types.HashedParams/block-max-bytes :tendermint.types.HashedParams/block-max-gas ]))
(def HashedParams-defaults {:block-max-bytes 0 :block-max-gas 0 })

(defn cis->HashedParams
  "CodedInputStream to HashedParams"
  [is]
  (->> (tag-map HashedParams-defaults
         (fn [tag index]
             (case index
               1 [:block-max-bytes (serdes.core/cis->Int64 is)]
               2 [:block-max-gas (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->HashedParams-record)))

(defn ecis->HashedParams
  "Embedded CodedInputStream to HashedParams"
  [is]
  (serdes.core/cis->embedded cis->HashedParams is))

(defn new-HashedParams
  "Creates a new instance from a map, similar to map->HashedParams except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::HashedParams-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::HashedParams-spec init))))]}
  (-> (merge HashedParams-defaults init)
      (map->HashedParams-record)))

(defn pb->HashedParams
  "Protobuf to HashedParams"
  [input]
  (cis->HashedParams (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record HashedParams-meta {:type "tendermint.types.HashedParams" :decoder pb->HashedParams})

;-----------------------------------------------------------------------------
; EvidenceParams
;-----------------------------------------------------------------------------
(defrecord EvidenceParams-record [max-age-num-blocks max-age-duration max-bytes]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int64 1  {:optimize true} (:max-age-num-blocks this) os)
    (serdes.core/write-embedded 2 (:max-age-duration this) os)
    (serdes.core/write-Int64 3  {:optimize true} (:max-bytes this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.EvidenceParams"))

(s/def :tendermint.types.EvidenceParams/max-age-num-blocks int?)

(s/def :tendermint.types.EvidenceParams/max-bytes int?)
(s/def ::EvidenceParams-spec (s/keys :opt-un [:tendermint.types.EvidenceParams/max-age-num-blocks :tendermint.types.EvidenceParams/max-bytes ]))
(def EvidenceParams-defaults {:max-age-num-blocks 0 :max-bytes 0 })

(defn cis->EvidenceParams
  "CodedInputStream to EvidenceParams"
  [is]
  (->> (tag-map EvidenceParams-defaults
         (fn [tag index]
             (case index
               1 [:max-age-num-blocks (serdes.core/cis->Int64 is)]
               2 [:max-age-duration (com.google.protobuf/ecis->Duration is)]
               3 [:max-bytes (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->EvidenceParams-record)))

(defn ecis->EvidenceParams
  "Embedded CodedInputStream to EvidenceParams"
  [is]
  (serdes.core/cis->embedded cis->EvidenceParams is))

(defn new-EvidenceParams
  "Creates a new instance from a map, similar to map->EvidenceParams except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EvidenceParams-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EvidenceParams-spec init))))]}
  (-> (merge EvidenceParams-defaults init)
      (cond-> (some? (get init :max-age-duration)) (update :max-age-duration com.google.protobuf/new-Duration))
      (map->EvidenceParams-record)))

(defn pb->EvidenceParams
  "Protobuf to EvidenceParams"
  [input]
  (cis->EvidenceParams (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EvidenceParams-meta {:type "tendermint.types.EvidenceParams" :decoder pb->EvidenceParams})

;-----------------------------------------------------------------------------
; SignedHeader
;-----------------------------------------------------------------------------
(defrecord SignedHeader-record [header commit]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:header this) os)
    (serdes.core/write-embedded 2 (:commit this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.SignedHeader"))

(s/def ::SignedHeader-spec (s/keys :opt-un []))
(def SignedHeader-defaults {})

(defn cis->SignedHeader
  "CodedInputStream to SignedHeader"
  [is]
  (->> (tag-map SignedHeader-defaults
         (fn [tag index]
             (case index
               1 [:header (ecis->Header is)]
               2 [:commit (ecis->Commit is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->SignedHeader-record)))

(defn ecis->SignedHeader
  "Embedded CodedInputStream to SignedHeader"
  [is]
  (serdes.core/cis->embedded cis->SignedHeader is))

(defn new-SignedHeader
  "Creates a new instance from a map, similar to map->SignedHeader except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SignedHeader-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SignedHeader-spec init))))]}
  (-> (merge SignedHeader-defaults init)
      (cond-> (some? (get init :header)) (update :header new-Header))
      (cond-> (some? (get init :commit)) (update :commit new-Commit))
      (map->SignedHeader-record)))

(defn pb->SignedHeader
  "Protobuf to SignedHeader"
  [input]
  (cis->SignedHeader (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SignedHeader-meta {:type "tendermint.types.SignedHeader" :decoder pb->SignedHeader})

;-----------------------------------------------------------------------------
; SimpleValidator
;-----------------------------------------------------------------------------
(defrecord SimpleValidator-record [pub-key voting-power]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:pub-key this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:voting-power this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.SimpleValidator"))

(s/def :tendermint.types.SimpleValidator/voting-power int?)
(s/def ::SimpleValidator-spec (s/keys :opt-un [:tendermint.types.SimpleValidator/voting-power ]))
(def SimpleValidator-defaults {:voting-power 0 })

(defn cis->SimpleValidator
  "CodedInputStream to SimpleValidator"
  [is]
  (->> (tag-map SimpleValidator-defaults
         (fn [tag index]
             (case index
               1 [:pub-key (tendermint.crypto/ecis->PublicKey is)]
               2 [:voting-power (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->SimpleValidator-record)))

(defn ecis->SimpleValidator
  "Embedded CodedInputStream to SimpleValidator"
  [is]
  (serdes.core/cis->embedded cis->SimpleValidator is))

(defn new-SimpleValidator
  "Creates a new instance from a map, similar to map->SimpleValidator except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SimpleValidator-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SimpleValidator-spec init))))]}
  (-> (merge SimpleValidator-defaults init)
      (cond-> (some? (get init :pub-key)) (update :pub-key tendermint.crypto/new-PublicKey))
      (map->SimpleValidator-record)))

(defn pb->SimpleValidator
  "Protobuf to SimpleValidator"
  [input]
  (cis->SimpleValidator (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SimpleValidator-meta {:type "tendermint.types.SimpleValidator" :decoder pb->SimpleValidator})

;-----------------------------------------------------------------------------
; Part
;-----------------------------------------------------------------------------
(defrecord Part-record [index bytes proof]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt32 1  {:optimize true} (:index this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:bytes this) os)
    (serdes.core/write-embedded 3 (:proof this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.Part"))

(s/def :tendermint.types.Part/index int?)
(s/def :tendermint.types.Part/bytes bytes?)

(s/def ::Part-spec (s/keys :opt-un [:tendermint.types.Part/index :tendermint.types.Part/bytes ]))
(def Part-defaults {:index 0 :bytes (byte-array 0) })

(defn cis->Part
  "CodedInputStream to Part"
  [is]
  (->> (tag-map Part-defaults
         (fn [tag index]
             (case index
               1 [:index (serdes.core/cis->UInt32 is)]
               2 [:bytes (serdes.core/cis->Bytes is)]
               3 [:proof (tendermint.crypto/ecis->Proof is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Part-record)))

(defn ecis->Part
  "Embedded CodedInputStream to Part"
  [is]
  (serdes.core/cis->embedded cis->Part is))

(defn new-Part
  "Creates a new instance from a map, similar to map->Part except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Part-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Part-spec init))))]}
  (-> (merge Part-defaults init)
      (cond-> (some? (get init :proof)) (update :proof tendermint.crypto/new-Proof))
      (map->Part-record)))

(defn pb->Part
  "Protobuf to Part"
  [input]
  (cis->Part (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Part-meta {:type "tendermint.types.Part" :decoder pb->Part})

;-----------------------------------------------------------------------------
; PartSetHeader
;-----------------------------------------------------------------------------
(defrecord PartSetHeader-record [total hash]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt32 1  {:optimize true} (:total this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:hash this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.PartSetHeader"))

(s/def :tendermint.types.PartSetHeader/total int?)
(s/def :tendermint.types.PartSetHeader/hash bytes?)
(s/def ::PartSetHeader-spec (s/keys :opt-un [:tendermint.types.PartSetHeader/total :tendermint.types.PartSetHeader/hash ]))
(def PartSetHeader-defaults {:total 0 :hash (byte-array 0) })

(defn cis->PartSetHeader
  "CodedInputStream to PartSetHeader"
  [is]
  (->> (tag-map PartSetHeader-defaults
         (fn [tag index]
             (case index
               1 [:total (serdes.core/cis->UInt32 is)]
               2 [:hash (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->PartSetHeader-record)))

(defn ecis->PartSetHeader
  "Embedded CodedInputStream to PartSetHeader"
  [is]
  (serdes.core/cis->embedded cis->PartSetHeader is))

(defn new-PartSetHeader
  "Creates a new instance from a map, similar to map->PartSetHeader except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::PartSetHeader-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::PartSetHeader-spec init))))]}
  (-> (merge PartSetHeader-defaults init)
      (map->PartSetHeader-record)))

(defn pb->PartSetHeader
  "Protobuf to PartSetHeader"
  [input]
  (cis->PartSetHeader (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record PartSetHeader-meta {:type "tendermint.types.PartSetHeader" :decoder pb->PartSetHeader})

;-----------------------------------------------------------------------------
; Data
;-----------------------------------------------------------------------------
(defrecord Data-record [txs]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-Bytes 1 (:txs this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.Data"))

(s/def :tendermint.types.Data/txs (s/every bytes?))
(s/def ::Data-spec (s/keys :opt-un [:tendermint.types.Data/txs ]))
(def Data-defaults {:txs [] })

(defn cis->Data
  "CodedInputStream to Data"
  [is]
  (->> (tag-map Data-defaults
         (fn [tag index]
             (case index
               1 [:txs (serdes.complex/cis->repeated serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Data-record)))

(defn ecis->Data
  "Embedded CodedInputStream to Data"
  [is]
  (serdes.core/cis->embedded cis->Data is))

(defn new-Data
  "Creates a new instance from a map, similar to map->Data except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Data-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Data-spec init))))]}
  (-> (merge Data-defaults init)
      (map->Data-record)))

(defn pb->Data
  "Protobuf to Data"
  [input]
  (cis->Data (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Data-meta {:type "tendermint.types.Data" :decoder pb->Data})

;-----------------------------------------------------------------------------
; VersionParams
;-----------------------------------------------------------------------------
(defrecord VersionParams-record [app-version]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt64 1  {:optimize true} (:app-version this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.VersionParams"))

(s/def :tendermint.types.VersionParams/app-version int?)
(s/def ::VersionParams-spec (s/keys :opt-un [:tendermint.types.VersionParams/app-version ]))
(def VersionParams-defaults {:app-version 0 })

(defn cis->VersionParams
  "CodedInputStream to VersionParams"
  [is]
  (->> (tag-map VersionParams-defaults
         (fn [tag index]
             (case index
               1 [:app-version (serdes.core/cis->UInt64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->VersionParams-record)))

(defn ecis->VersionParams
  "Embedded CodedInputStream to VersionParams"
  [is]
  (serdes.core/cis->embedded cis->VersionParams is))

(defn new-VersionParams
  "Creates a new instance from a map, similar to map->VersionParams except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::VersionParams-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::VersionParams-spec init))))]}
  (-> (merge VersionParams-defaults init)
      (map->VersionParams-record)))

(defn pb->VersionParams
  "Protobuf to VersionParams"
  [input]
  (cis->VersionParams (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record VersionParams-meta {:type "tendermint.types.VersionParams" :decoder pb->VersionParams})

;-----------------------------------------------------------------------------
; ValidatorSet
;-----------------------------------------------------------------------------
(defrecord ValidatorSet-record [validators proposer total-voting-power]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:validators this) os)
    (serdes.core/write-embedded 2 (:proposer this) os)
    (serdes.core/write-Int64 3  {:optimize true} (:total-voting-power this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.ValidatorSet"))

(s/def :tendermint.types.ValidatorSet/total-voting-power int?)
(s/def ::ValidatorSet-spec (s/keys :opt-un [:tendermint.types.ValidatorSet/total-voting-power ]))
(def ValidatorSet-defaults {:validators [] :total-voting-power 0 })

(defn cis->ValidatorSet
  "CodedInputStream to ValidatorSet"
  [is]
  (->> (tag-map ValidatorSet-defaults
         (fn [tag index]
             (case index
               1 [:validators (serdes.complex/cis->repeated ecis->Validator is)]
               2 [:proposer (ecis->Validator is)]
               3 [:total-voting-power (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ValidatorSet-record)))

(defn ecis->ValidatorSet
  "Embedded CodedInputStream to ValidatorSet"
  [is]
  (serdes.core/cis->embedded cis->ValidatorSet is))

(defn new-ValidatorSet
  "Creates a new instance from a map, similar to map->ValidatorSet except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ValidatorSet-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ValidatorSet-spec init))))]}
  (-> (merge ValidatorSet-defaults init)
      (cond-> (some? (get init :validators)) (update :validators #(map new-Validator %)))
      (cond-> (some? (get init :proposer)) (update :proposer new-Validator))
      (map->ValidatorSet-record)))

(defn pb->ValidatorSet
  "Protobuf to ValidatorSet"
  [input]
  (cis->ValidatorSet (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ValidatorSet-meta {:type "tendermint.types.ValidatorSet" :decoder pb->ValidatorSet})

;-----------------------------------------------------------------------------
; TxProof
;-----------------------------------------------------------------------------
(defrecord TxProof-record [root-hash data proof]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:root-hash this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:data this) os)
    (serdes.core/write-embedded 3 (:proof this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.TxProof"))

(s/def :tendermint.types.TxProof/root-hash bytes?)
(s/def :tendermint.types.TxProof/data bytes?)

(s/def ::TxProof-spec (s/keys :opt-un [:tendermint.types.TxProof/root-hash :tendermint.types.TxProof/data ]))
(def TxProof-defaults {:root-hash (byte-array 0) :data (byte-array 0) })

(defn cis->TxProof
  "CodedInputStream to TxProof"
  [is]
  (->> (tag-map TxProof-defaults
         (fn [tag index]
             (case index
               1 [:root-hash (serdes.core/cis->Bytes is)]
               2 [:data (serdes.core/cis->Bytes is)]
               3 [:proof (tendermint.crypto/ecis->Proof is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->TxProof-record)))

(defn ecis->TxProof
  "Embedded CodedInputStream to TxProof"
  [is]
  (serdes.core/cis->embedded cis->TxProof is))

(defn new-TxProof
  "Creates a new instance from a map, similar to map->TxProof except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TxProof-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TxProof-spec init))))]}
  (-> (merge TxProof-defaults init)
      (cond-> (some? (get init :proof)) (update :proof tendermint.crypto/new-Proof))
      (map->TxProof-record)))

(defn pb->TxProof
  "Protobuf to TxProof"
  [input]
  (cis->TxProof (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record TxProof-meta {:type "tendermint.types.TxProof" :decoder pb->TxProof})

;-----------------------------------------------------------------------------
; LightBlock
;-----------------------------------------------------------------------------
(defrecord LightBlock-record [signed-header validator-set]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:signed-header this) os)
    (serdes.core/write-embedded 2 (:validator-set this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.LightBlock"))

(s/def ::LightBlock-spec (s/keys :opt-un []))
(def LightBlock-defaults {})

(defn cis->LightBlock
  "CodedInputStream to LightBlock"
  [is]
  (->> (tag-map LightBlock-defaults
         (fn [tag index]
             (case index
               1 [:signed-header (ecis->SignedHeader is)]
               2 [:validator-set (ecis->ValidatorSet is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->LightBlock-record)))

(defn ecis->LightBlock
  "Embedded CodedInputStream to LightBlock"
  [is]
  (serdes.core/cis->embedded cis->LightBlock is))

(defn new-LightBlock
  "Creates a new instance from a map, similar to map->LightBlock except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LightBlock-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LightBlock-spec init))))]}
  (-> (merge LightBlock-defaults init)
      (cond-> (some? (get init :signed-header)) (update :signed-header new-SignedHeader))
      (cond-> (some? (get init :validator-set)) (update :validator-set new-ValidatorSet))
      (map->LightBlock-record)))

(defn pb->LightBlock
  "Protobuf to LightBlock"
  [input]
  (cis->LightBlock (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record LightBlock-meta {:type "tendermint.types.LightBlock" :decoder pb->LightBlock})

;-----------------------------------------------------------------------------
; LightClientAttackEvidence
;-----------------------------------------------------------------------------
(defrecord LightClientAttackEvidence-record [conflicting-block common-height byzantine-validators total-voting-power timestamp]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:conflicting-block this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:common-height this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 3 (:byzantine-validators this) os)
    (serdes.core/write-Int64 4  {:optimize true} (:total-voting-power this) os)
    (serdes.core/write-embedded 5 (:timestamp this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.LightClientAttackEvidence"))

(s/def :tendermint.types.LightClientAttackEvidence/common-height int?)

(s/def :tendermint.types.LightClientAttackEvidence/total-voting-power int?)

(s/def ::LightClientAttackEvidence-spec (s/keys :opt-un [:tendermint.types.LightClientAttackEvidence/common-height :tendermint.types.LightClientAttackEvidence/total-voting-power ]))
(def LightClientAttackEvidence-defaults {:common-height 0 :byzantine-validators [] :total-voting-power 0 })

(defn cis->LightClientAttackEvidence
  "CodedInputStream to LightClientAttackEvidence"
  [is]
  (->> (tag-map LightClientAttackEvidence-defaults
         (fn [tag index]
             (case index
               1 [:conflicting-block (ecis->LightBlock is)]
               2 [:common-height (serdes.core/cis->Int64 is)]
               3 [:byzantine-validators (serdes.complex/cis->repeated ecis->Validator is)]
               4 [:total-voting-power (serdes.core/cis->Int64 is)]
               5 [:timestamp (com.google.protobuf/ecis->Timestamp is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->LightClientAttackEvidence-record)))

(defn ecis->LightClientAttackEvidence
  "Embedded CodedInputStream to LightClientAttackEvidence"
  [is]
  (serdes.core/cis->embedded cis->LightClientAttackEvidence is))

(defn new-LightClientAttackEvidence
  "Creates a new instance from a map, similar to map->LightClientAttackEvidence except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LightClientAttackEvidence-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LightClientAttackEvidence-spec init))))]}
  (-> (merge LightClientAttackEvidence-defaults init)
      (cond-> (some? (get init :conflicting-block)) (update :conflicting-block new-LightBlock))
      (cond-> (some? (get init :byzantine-validators)) (update :byzantine-validators #(map new-Validator %)))
      (cond-> (some? (get init :timestamp)) (update :timestamp com.google.protobuf/new-Timestamp))
      (map->LightClientAttackEvidence-record)))

(defn pb->LightClientAttackEvidence
  "Protobuf to LightClientAttackEvidence"
  [input]
  (cis->LightClientAttackEvidence (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record LightClientAttackEvidence-meta {:type "tendermint.types.LightClientAttackEvidence" :decoder pb->LightClientAttackEvidence})

;-----------------------------------------------------------------------------
; BlockParams
;-----------------------------------------------------------------------------
(defrecord BlockParams-record [max-bytes max-gas]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int64 1  {:optimize true} (:max-bytes this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:max-gas this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.BlockParams"))

(s/def :tendermint.types.BlockParams/max-bytes int?)
(s/def :tendermint.types.BlockParams/max-gas int?)
(s/def ::BlockParams-spec (s/keys :opt-un [:tendermint.types.BlockParams/max-bytes :tendermint.types.BlockParams/max-gas ]))
(def BlockParams-defaults {:max-bytes 0 :max-gas 0 })

(defn cis->BlockParams
  "CodedInputStream to BlockParams"
  [is]
  (->> (tag-map BlockParams-defaults
         (fn [tag index]
             (case index
               1 [:max-bytes (serdes.core/cis->Int64 is)]
               2 [:max-gas (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BlockParams-record)))

(defn ecis->BlockParams
  "Embedded CodedInputStream to BlockParams"
  [is]
  (serdes.core/cis->embedded cis->BlockParams is))

(defn new-BlockParams
  "Creates a new instance from a map, similar to map->BlockParams except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BlockParams-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BlockParams-spec init))))]}
  (-> (merge BlockParams-defaults init)
      (map->BlockParams-record)))

(defn pb->BlockParams
  "Protobuf to BlockParams"
  [input]
  (cis->BlockParams (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BlockParams-meta {:type "tendermint.types.BlockParams" :decoder pb->BlockParams})

;-----------------------------------------------------------------------------
; Validator
;-----------------------------------------------------------------------------
(defrecord Validator-record [address pub-key voting-power proposer-priority]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:address this) os)
    (serdes.core/write-embedded 2 (:pub-key this) os)
    (serdes.core/write-Int64 3  {:optimize true} (:voting-power this) os)
    (serdes.core/write-Int64 4  {:optimize true} (:proposer-priority this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.types.Validator"))

(s/def :tendermint.types.Validator/address bytes?)

(s/def :tendermint.types.Validator/voting-power int?)
(s/def :tendermint.types.Validator/proposer-priority int?)
(s/def ::Validator-spec (s/keys :opt-un [:tendermint.types.Validator/address :tendermint.types.Validator/voting-power :tendermint.types.Validator/proposer-priority ]))
(def Validator-defaults {:address (byte-array 0) :voting-power 0 :proposer-priority 0 })

(defn cis->Validator
  "CodedInputStream to Validator"
  [is]
  (->> (tag-map Validator-defaults
         (fn [tag index]
             (case index
               1 [:address (serdes.core/cis->Bytes is)]
               2 [:pub-key (tendermint.crypto/ecis->PublicKey is)]
               3 [:voting-power (serdes.core/cis->Int64 is)]
               4 [:proposer-priority (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Validator-record)))

(defn ecis->Validator
  "Embedded CodedInputStream to Validator"
  [is]
  (serdes.core/cis->embedded cis->Validator is))

(defn new-Validator
  "Creates a new instance from a map, similar to map->Validator except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Validator-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Validator-spec init))))]}
  (-> (merge Validator-defaults init)
      (cond-> (some? (get init :pub-key)) (update :pub-key tendermint.crypto/new-PublicKey))
      (map->Validator-record)))

(defn pb->Validator
  "Protobuf to Validator"
  [input]
  (cis->Validator (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Validator-meta {:type "tendermint.types.Validator" :decoder pb->Validator})

