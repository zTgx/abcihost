;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package tendermint.abci
;;;----------------------------------------------------------------------------------
(ns tendermint.abci
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [com.google.protobuf :as com.google.protobuf]
            [tendermint.types :as tendermint.types]
            [tendermint.crypto :as tendermint.crypto]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->ResponseCheckTx)
(declare ecis->ResponseCheckTx)
(declare new-ResponseCheckTx)
(declare cis->RequestInfo)
(declare ecis->RequestInfo)
(declare new-RequestInfo)
(declare cis->ResponseListSnapshots)
(declare ecis->ResponseListSnapshots)
(declare new-ResponseListSnapshots)
(declare cis->RequestApplySnapshotChunk)
(declare ecis->RequestApplySnapshotChunk)
(declare new-RequestApplySnapshotChunk)
(declare cis->ResponseBeginBlock)
(declare ecis->ResponseBeginBlock)
(declare new-ResponseBeginBlock)
(declare cis->RequestEcho)
(declare ecis->RequestEcho)
(declare new-RequestEcho)
(declare cis->EventAttribute)
(declare ecis->EventAttribute)
(declare new-EventAttribute)
(declare cis->ResponseEndBlock)
(declare ecis->ResponseEndBlock)
(declare new-ResponseEndBlock)
(declare cis->Request)
(declare ecis->Request)
(declare new-Request)
(declare cis->ResponseOfferSnapshot)
(declare ecis->ResponseOfferSnapshot)
(declare new-ResponseOfferSnapshot)
(declare cis->RequestFlush)
(declare ecis->RequestFlush)
(declare new-RequestFlush)
(declare cis->RequestBeginBlock)
(declare ecis->RequestBeginBlock)
(declare new-RequestBeginBlock)
(declare cis->ResponseDeliverTx)
(declare ecis->ResponseDeliverTx)
(declare new-ResponseDeliverTx)
(declare cis->ResponseEcho)
(declare ecis->ResponseEcho)
(declare new-ResponseEcho)
(declare cis->RequestCheckTx)
(declare ecis->RequestCheckTx)
(declare new-RequestCheckTx)
(declare cis->ResponseQuery)
(declare ecis->ResponseQuery)
(declare new-ResponseQuery)
(declare cis->VoteInfo)
(declare ecis->VoteInfo)
(declare new-VoteInfo)
(declare cis->Evidence)
(declare ecis->Evidence)
(declare new-Evidence)
(declare cis->ResponseException)
(declare ecis->ResponseException)
(declare new-ResponseException)
(declare cis->Event)
(declare ecis->Event)
(declare new-Event)
(declare cis->RequestEndBlock)
(declare ecis->RequestEndBlock)
(declare new-RequestEndBlock)
(declare cis->RequestListSnapshots)
(declare ecis->RequestListSnapshots)
(declare new-RequestListSnapshots)
(declare cis->Response)
(declare ecis->Response)
(declare new-Response)
(declare cis->RequestQuery)
(declare ecis->RequestQuery)
(declare new-RequestQuery)
(declare cis->RequestOfferSnapshot)
(declare ecis->RequestOfferSnapshot)
(declare new-RequestOfferSnapshot)
(declare cis->LastCommitInfo)
(declare ecis->LastCommitInfo)
(declare new-LastCommitInfo)
(declare cis->RequestInitChain)
(declare ecis->RequestInitChain)
(declare new-RequestInitChain)
(declare cis->Snapshot)
(declare ecis->Snapshot)
(declare new-Snapshot)
(declare cis->ResponseLoadSnapshotChunk)
(declare ecis->ResponseLoadSnapshotChunk)
(declare new-ResponseLoadSnapshotChunk)
(declare cis->ValidatorUpdate)
(declare ecis->ValidatorUpdate)
(declare new-ValidatorUpdate)
(declare cis->TxResult)
(declare ecis->TxResult)
(declare new-TxResult)
(declare cis->RequestLoadSnapshotChunk)
(declare ecis->RequestLoadSnapshotChunk)
(declare new-RequestLoadSnapshotChunk)
(declare cis->ResponseInitChain)
(declare ecis->ResponseInitChain)
(declare new-ResponseInitChain)
(declare cis->RequestDeliverTx)
(declare ecis->RequestDeliverTx)
(declare new-RequestDeliverTx)
(declare cis->ResponseFlush)
(declare ecis->ResponseFlush)
(declare new-ResponseFlush)
(declare cis->ResponseInfo)
(declare ecis->ResponseInfo)
(declare new-ResponseInfo)
(declare cis->RequestCommit)
(declare ecis->RequestCommit)
(declare new-RequestCommit)
(declare cis->ResponseCommit)
(declare ecis->ResponseCommit)
(declare new-ResponseCommit)
(declare cis->ResponseApplySnapshotChunk)
(declare ecis->ResponseApplySnapshotChunk)
(declare new-ResponseApplySnapshotChunk)
(declare cis->Validator)
(declare ecis->Validator)
(declare new-Validator)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; CheckTxType
;-----------------------------------------------------------------------------
(def CheckTxType-default :new)

(def CheckTxType-val2label {
  0 :new
  1 :recheck})

(def CheckTxType-label2val (set/map-invert CheckTxType-val2label))

(defn cis->CheckTxType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get CheckTxType-val2label val val)))

(defn- get-CheckTxType [value]
  {:pre [(or (int? value) (contains? CheckTxType-label2val value))]}
  (get CheckTxType-label2val value value))

(defn write-CheckTxType
  ([tag value os] (write-CheckTxType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-CheckTxType value) os)))

;-----------------------------------------------------------------------------
; EvidenceType
;-----------------------------------------------------------------------------
(def EvidenceType-default :unknown)

(def EvidenceType-val2label {
  0 :unknown
  1 :duplicate-vote
  2 :light-client-attack})

(def EvidenceType-label2val (set/map-invert EvidenceType-val2label))

(defn cis->EvidenceType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get EvidenceType-val2label val val)))

(defn- get-EvidenceType [value]
  {:pre [(or (int? value) (contains? EvidenceType-label2val value))]}
  (get EvidenceType-label2val value value))

(defn write-EvidenceType
  ([tag value os] (write-EvidenceType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-EvidenceType value) os)))

;-----------------------------------------------------------------------------
; ResponseOfferSnapshot-Result
;-----------------------------------------------------------------------------
(def ResponseOfferSnapshot-Result-default :unknown)

(def ResponseOfferSnapshot-Result-val2label {
  0 :unknown
  1 :accept
  2 :abort
  3 :reject
  4 :reject-format
  5 :reject-sender})

(def ResponseOfferSnapshot-Result-label2val (set/map-invert ResponseOfferSnapshot-Result-val2label))

(defn cis->ResponseOfferSnapshot-Result [is]
  (let [val (serdes.core/cis->Enum is)]
    (get ResponseOfferSnapshot-Result-val2label val val)))

(defn- get-ResponseOfferSnapshot-Result [value]
  {:pre [(or (int? value) (contains? ResponseOfferSnapshot-Result-label2val value))]}
  (get ResponseOfferSnapshot-Result-label2val value value))

(defn write-ResponseOfferSnapshot-Result
  ([tag value os] (write-ResponseOfferSnapshot-Result tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-ResponseOfferSnapshot-Result value) os)))

;-----------------------------------------------------------------------------
; ResponseApplySnapshotChunk-Result
;-----------------------------------------------------------------------------
(def ResponseApplySnapshotChunk-Result-default :unknown)

(def ResponseApplySnapshotChunk-Result-val2label {
  0 :unknown
  1 :accept
  2 :abort
  3 :retry
  4 :retry-snapshot
  5 :reject-snapshot})

(def ResponseApplySnapshotChunk-Result-label2val (set/map-invert ResponseApplySnapshotChunk-Result-val2label))

(defn cis->ResponseApplySnapshotChunk-Result [is]
  (let [val (serdes.core/cis->Enum is)]
    (get ResponseApplySnapshotChunk-Result-val2label val val)))

(defn- get-ResponseApplySnapshotChunk-Result [value]
  {:pre [(or (int? value) (contains? ResponseApplySnapshotChunk-Result-label2val value))]}
  (get ResponseApplySnapshotChunk-Result-label2val value value))

(defn write-ResponseApplySnapshotChunk-Result
  ([tag value os] (write-ResponseApplySnapshotChunk-Result tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-ResponseApplySnapshotChunk-Result value) os)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Request-value's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Request-value [origkeyval]
  (cond
     (get-in origkeyval [:value :begin-block]) (update-in origkeyval [:value :begin-block] new-RequestBeginBlock)
     (get-in origkeyval [:value :query]) (update-in origkeyval [:value :query] new-RequestQuery)
     (get-in origkeyval [:value :info]) (update-in origkeyval [:value :info] new-RequestInfo)
     (get-in origkeyval [:value :flush]) (update-in origkeyval [:value :flush] new-RequestFlush)
     (get-in origkeyval [:value :end-block]) (update-in origkeyval [:value :end-block] new-RequestEndBlock)
     (get-in origkeyval [:value :offer-snapshot]) (update-in origkeyval [:value :offer-snapshot] new-RequestOfferSnapshot)
     (get-in origkeyval [:value :apply-snapshot-chunk]) (update-in origkeyval [:value :apply-snapshot-chunk] new-RequestApplySnapshotChunk)
     (get-in origkeyval [:value :commit]) (update-in origkeyval [:value :commit] new-RequestCommit)
     (get-in origkeyval [:value :load-snapshot-chunk]) (update-in origkeyval [:value :load-snapshot-chunk] new-RequestLoadSnapshotChunk)
     (get-in origkeyval [:value :init-chain]) (update-in origkeyval [:value :init-chain] new-RequestInitChain)
     (get-in origkeyval [:value :check-tx]) (update-in origkeyval [:value :check-tx] new-RequestCheckTx)
     (get-in origkeyval [:value :deliver-tx]) (update-in origkeyval [:value :deliver-tx] new-RequestDeliverTx)
     (get-in origkeyval [:value :echo]) (update-in origkeyval [:value :echo] new-RequestEcho)
     (get-in origkeyval [:value :list-snapshots]) (update-in origkeyval [:value :list-snapshots] new-RequestListSnapshots)
     :default origkeyval))

(defn write-Request-value [value os]
  (let [field (first value)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :begin-block (serdes.core/write-embedded 6 v os)
         :query (serdes.core/write-embedded 5 v os)
         :info (serdes.core/write-embedded 3 v os)
         :flush (serdes.core/write-embedded 2 v os)
         :end-block (serdes.core/write-embedded 9 v os)
         :offer-snapshot (serdes.core/write-embedded 12 v os)
         :apply-snapshot-chunk (serdes.core/write-embedded 14 v os)
         :commit (serdes.core/write-embedded 10 v os)
         :load-snapshot-chunk (serdes.core/write-embedded 13 v os)
         :init-chain (serdes.core/write-embedded 4 v os)
         :check-tx (serdes.core/write-embedded 7 v os)
         :deliver-tx (serdes.core/write-embedded 8 v os)
         :echo (serdes.core/write-embedded 1 v os)
         :list-snapshots (serdes.core/write-embedded 11 v os)
         nil)))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Response-value's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Response-value [origkeyval]
  (cond
     (get-in origkeyval [:value :begin-block]) (update-in origkeyval [:value :begin-block] new-ResponseBeginBlock)
     (get-in origkeyval [:value :query]) (update-in origkeyval [:value :query] new-ResponseQuery)
     (get-in origkeyval [:value :info]) (update-in origkeyval [:value :info] new-ResponseInfo)
     (get-in origkeyval [:value :exception]) (update-in origkeyval [:value :exception] new-ResponseException)
     (get-in origkeyval [:value :flush]) (update-in origkeyval [:value :flush] new-ResponseFlush)
     (get-in origkeyval [:value :end-block]) (update-in origkeyval [:value :end-block] new-ResponseEndBlock)
     (get-in origkeyval [:value :offer-snapshot]) (update-in origkeyval [:value :offer-snapshot] new-ResponseOfferSnapshot)
     (get-in origkeyval [:value :apply-snapshot-chunk]) (update-in origkeyval [:value :apply-snapshot-chunk] new-ResponseApplySnapshotChunk)
     (get-in origkeyval [:value :commit]) (update-in origkeyval [:value :commit] new-ResponseCommit)
     (get-in origkeyval [:value :load-snapshot-chunk]) (update-in origkeyval [:value :load-snapshot-chunk] new-ResponseLoadSnapshotChunk)
     (get-in origkeyval [:value :init-chain]) (update-in origkeyval [:value :init-chain] new-ResponseInitChain)
     (get-in origkeyval [:value :check-tx]) (update-in origkeyval [:value :check-tx] new-ResponseCheckTx)
     (get-in origkeyval [:value :deliver-tx]) (update-in origkeyval [:value :deliver-tx] new-ResponseDeliverTx)
     (get-in origkeyval [:value :echo]) (update-in origkeyval [:value :echo] new-ResponseEcho)
     (get-in origkeyval [:value :list-snapshots]) (update-in origkeyval [:value :list-snapshots] new-ResponseListSnapshots)
     :default origkeyval))

(defn write-Response-value [value os]
  (let [field (first value)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :begin-block (serdes.core/write-embedded 7 v os)
         :query (serdes.core/write-embedded 6 v os)
         :info (serdes.core/write-embedded 4 v os)
         :exception (serdes.core/write-embedded 1 v os)
         :flush (serdes.core/write-embedded 3 v os)
         :end-block (serdes.core/write-embedded 10 v os)
         :offer-snapshot (serdes.core/write-embedded 13 v os)
         :apply-snapshot-chunk (serdes.core/write-embedded 15 v os)
         :commit (serdes.core/write-embedded 11 v os)
         :load-snapshot-chunk (serdes.core/write-embedded 14 v os)
         :init-chain (serdes.core/write-embedded 5 v os)
         :check-tx (serdes.core/write-embedded 8 v os)
         :deliver-tx (serdes.core/write-embedded 9 v os)
         :echo (serdes.core/write-embedded 2 v os)
         :list-snapshots (serdes.core/write-embedded 12 v os)
         nil)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; ResponseCheckTx
;-----------------------------------------------------------------------------
(defrecord ResponseCheckTx-record [priority gas-wanted info log mempool-error gas-used events sender data code codespace]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int64 10  {:optimize true} (:priority this) os)
    (serdes.core/write-Int64 5  {:optimize true} (:gas-wanted this) os)
    (serdes.core/write-String 4  {:optimize true} (:info this) os)
    (serdes.core/write-String 3  {:optimize true} (:log this) os)
    (serdes.core/write-String 11  {:optimize true} (:mempool-error this) os)
    (serdes.core/write-Int64 6  {:optimize true} (:gas-used this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 7 (:events this) os)
    (serdes.core/write-String 9  {:optimize true} (:sender this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:data this) os)
    (serdes.core/write-UInt32 1  {:optimize true} (:code this) os)
    (serdes.core/write-String 8  {:optimize true} (:codespace this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseCheckTx"))

(s/def :tendermint.abci.ResponseCheckTx/priority int?)
(s/def :tendermint.abci.ResponseCheckTx/gas-wanted int?)
(s/def :tendermint.abci.ResponseCheckTx/info string?)
(s/def :tendermint.abci.ResponseCheckTx/log string?)
(s/def :tendermint.abci.ResponseCheckTx/mempool-error string?)
(s/def :tendermint.abci.ResponseCheckTx/gas-used int?)

(s/def :tendermint.abci.ResponseCheckTx/sender string?)
(s/def :tendermint.abci.ResponseCheckTx/data bytes?)
(s/def :tendermint.abci.ResponseCheckTx/code int?)
(s/def :tendermint.abci.ResponseCheckTx/codespace string?)
(s/def ::ResponseCheckTx-spec (s/keys :opt-un [:tendermint.abci.ResponseCheckTx/priority :tendermint.abci.ResponseCheckTx/gas-wanted :tendermint.abci.ResponseCheckTx/info :tendermint.abci.ResponseCheckTx/log :tendermint.abci.ResponseCheckTx/mempool-error :tendermint.abci.ResponseCheckTx/gas-used :tendermint.abci.ResponseCheckTx/sender :tendermint.abci.ResponseCheckTx/data :tendermint.abci.ResponseCheckTx/code :tendermint.abci.ResponseCheckTx/codespace ]))
(def ResponseCheckTx-defaults {:priority 0 :gas-wanted 0 :info "" :log "" :mempool-error "" :gas-used 0 :events [] :sender "" :data (byte-array 0) :code 0 :codespace "" })

(defn cis->ResponseCheckTx
  "CodedInputStream to ResponseCheckTx"
  [is]
  (->> (tag-map ResponseCheckTx-defaults
         (fn [tag index]
             (case index
               10 [:priority (serdes.core/cis->Int64 is)]
               5 [:gas-wanted (serdes.core/cis->Int64 is)]
               4 [:info (serdes.core/cis->String is)]
               3 [:log (serdes.core/cis->String is)]
               11 [:mempool-error (serdes.core/cis->String is)]
               6 [:gas-used (serdes.core/cis->Int64 is)]
               7 [:events (serdes.complex/cis->repeated ecis->Event is)]
               9 [:sender (serdes.core/cis->String is)]
               2 [:data (serdes.core/cis->Bytes is)]
               1 [:code (serdes.core/cis->UInt32 is)]
               8 [:codespace (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseCheckTx-record)))

(defn ecis->ResponseCheckTx
  "Embedded CodedInputStream to ResponseCheckTx"
  [is]
  (serdes.core/cis->embedded cis->ResponseCheckTx is))

(defn new-ResponseCheckTx
  "Creates a new instance from a map, similar to map->ResponseCheckTx except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseCheckTx-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseCheckTx-spec init))))]}
  (-> (merge ResponseCheckTx-defaults init)
      (cond-> (some? (get init :events)) (update :events #(map new-Event %)))
      (map->ResponseCheckTx-record)))

(defn pb->ResponseCheckTx
  "Protobuf to ResponseCheckTx"
  [input]
  (cis->ResponseCheckTx (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseCheckTx-meta {:type "tendermint.abci.ResponseCheckTx" :decoder pb->ResponseCheckTx})

;-----------------------------------------------------------------------------
; RequestInfo
;-----------------------------------------------------------------------------
(defrecord RequestInfo-record [version block-version p2p-version abci-version]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:version this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:block-version this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:p2p-version this) os)
    (serdes.core/write-String 4  {:optimize true} (:abci-version this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestInfo"))

(s/def :tendermint.abci.RequestInfo/version string?)
(s/def :tendermint.abci.RequestInfo/block-version int?)
(s/def :tendermint.abci.RequestInfo/p2p-version int?)
(s/def :tendermint.abci.RequestInfo/abci-version string?)
(s/def ::RequestInfo-spec (s/keys :opt-un [:tendermint.abci.RequestInfo/version :tendermint.abci.RequestInfo/block-version :tendermint.abci.RequestInfo/p2p-version :tendermint.abci.RequestInfo/abci-version ]))
(def RequestInfo-defaults {:version "" :block-version 0 :p2p-version 0 :abci-version "" })

(defn cis->RequestInfo
  "CodedInputStream to RequestInfo"
  [is]
  (->> (tag-map RequestInfo-defaults
         (fn [tag index]
             (case index
               1 [:version (serdes.core/cis->String is)]
               2 [:block-version (serdes.core/cis->UInt64 is)]
               3 [:p2p-version (serdes.core/cis->UInt64 is)]
               4 [:abci-version (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestInfo-record)))

(defn ecis->RequestInfo
  "Embedded CodedInputStream to RequestInfo"
  [is]
  (serdes.core/cis->embedded cis->RequestInfo is))

(defn new-RequestInfo
  "Creates a new instance from a map, similar to map->RequestInfo except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestInfo-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestInfo-spec init))))]}
  (-> (merge RequestInfo-defaults init)
      (map->RequestInfo-record)))

(defn pb->RequestInfo
  "Protobuf to RequestInfo"
  [input]
  (cis->RequestInfo (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestInfo-meta {:type "tendermint.abci.RequestInfo" :decoder pb->RequestInfo})

;-----------------------------------------------------------------------------
; ResponseListSnapshots
;-----------------------------------------------------------------------------
(defrecord ResponseListSnapshots-record [snapshots]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:snapshots this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseListSnapshots"))

(s/def ::ResponseListSnapshots-spec (s/keys :opt-un []))
(def ResponseListSnapshots-defaults {:snapshots [] })

(defn cis->ResponseListSnapshots
  "CodedInputStream to ResponseListSnapshots"
  [is]
  (->> (tag-map ResponseListSnapshots-defaults
         (fn [tag index]
             (case index
               1 [:snapshots (serdes.complex/cis->repeated ecis->Snapshot is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseListSnapshots-record)))

(defn ecis->ResponseListSnapshots
  "Embedded CodedInputStream to ResponseListSnapshots"
  [is]
  (serdes.core/cis->embedded cis->ResponseListSnapshots is))

(defn new-ResponseListSnapshots
  "Creates a new instance from a map, similar to map->ResponseListSnapshots except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseListSnapshots-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseListSnapshots-spec init))))]}
  (-> (merge ResponseListSnapshots-defaults init)
      (cond-> (some? (get init :snapshots)) (update :snapshots #(map new-Snapshot %)))
      (map->ResponseListSnapshots-record)))

(defn pb->ResponseListSnapshots
  "Protobuf to ResponseListSnapshots"
  [input]
  (cis->ResponseListSnapshots (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseListSnapshots-meta {:type "tendermint.abci.ResponseListSnapshots" :decoder pb->ResponseListSnapshots})

;-----------------------------------------------------------------------------
; RequestApplySnapshotChunk
;-----------------------------------------------------------------------------
(defrecord RequestApplySnapshotChunk-record [index chunk sender]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt32 1  {:optimize true} (:index this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:chunk this) os)
    (serdes.core/write-String 3  {:optimize true} (:sender this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestApplySnapshotChunk"))

(s/def :tendermint.abci.RequestApplySnapshotChunk/index int?)
(s/def :tendermint.abci.RequestApplySnapshotChunk/chunk bytes?)
(s/def :tendermint.abci.RequestApplySnapshotChunk/sender string?)
(s/def ::RequestApplySnapshotChunk-spec (s/keys :opt-un [:tendermint.abci.RequestApplySnapshotChunk/index :tendermint.abci.RequestApplySnapshotChunk/chunk :tendermint.abci.RequestApplySnapshotChunk/sender ]))
(def RequestApplySnapshotChunk-defaults {:index 0 :chunk (byte-array 0) :sender "" })

(defn cis->RequestApplySnapshotChunk
  "CodedInputStream to RequestApplySnapshotChunk"
  [is]
  (->> (tag-map RequestApplySnapshotChunk-defaults
         (fn [tag index]
             (case index
               1 [:index (serdes.core/cis->UInt32 is)]
               2 [:chunk (serdes.core/cis->Bytes is)]
               3 [:sender (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestApplySnapshotChunk-record)))

(defn ecis->RequestApplySnapshotChunk
  "Embedded CodedInputStream to RequestApplySnapshotChunk"
  [is]
  (serdes.core/cis->embedded cis->RequestApplySnapshotChunk is))

(defn new-RequestApplySnapshotChunk
  "Creates a new instance from a map, similar to map->RequestApplySnapshotChunk except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestApplySnapshotChunk-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestApplySnapshotChunk-spec init))))]}
  (-> (merge RequestApplySnapshotChunk-defaults init)
      (map->RequestApplySnapshotChunk-record)))

(defn pb->RequestApplySnapshotChunk
  "Protobuf to RequestApplySnapshotChunk"
  [input]
  (cis->RequestApplySnapshotChunk (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestApplySnapshotChunk-meta {:type "tendermint.abci.RequestApplySnapshotChunk" :decoder pb->RequestApplySnapshotChunk})

;-----------------------------------------------------------------------------
; ResponseBeginBlock
;-----------------------------------------------------------------------------
(defrecord ResponseBeginBlock-record [events]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:events this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseBeginBlock"))

(s/def ::ResponseBeginBlock-spec (s/keys :opt-un []))
(def ResponseBeginBlock-defaults {:events [] })

(defn cis->ResponseBeginBlock
  "CodedInputStream to ResponseBeginBlock"
  [is]
  (->> (tag-map ResponseBeginBlock-defaults
         (fn [tag index]
             (case index
               1 [:events (serdes.complex/cis->repeated ecis->Event is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseBeginBlock-record)))

(defn ecis->ResponseBeginBlock
  "Embedded CodedInputStream to ResponseBeginBlock"
  [is]
  (serdes.core/cis->embedded cis->ResponseBeginBlock is))

(defn new-ResponseBeginBlock
  "Creates a new instance from a map, similar to map->ResponseBeginBlock except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseBeginBlock-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseBeginBlock-spec init))))]}
  (-> (merge ResponseBeginBlock-defaults init)
      (cond-> (some? (get init :events)) (update :events #(map new-Event %)))
      (map->ResponseBeginBlock-record)))

(defn pb->ResponseBeginBlock
  "Protobuf to ResponseBeginBlock"
  [input]
  (cis->ResponseBeginBlock (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseBeginBlock-meta {:type "tendermint.abci.ResponseBeginBlock" :decoder pb->ResponseBeginBlock})

;-----------------------------------------------------------------------------
; RequestEcho
;-----------------------------------------------------------------------------
(defrecord RequestEcho-record [message]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:message this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestEcho"))

(s/def :tendermint.abci.RequestEcho/message string?)
(s/def ::RequestEcho-spec (s/keys :opt-un [:tendermint.abci.RequestEcho/message ]))
(def RequestEcho-defaults {:message "" })

(defn cis->RequestEcho
  "CodedInputStream to RequestEcho"
  [is]
  (->> (tag-map RequestEcho-defaults
         (fn [tag index]
             (case index
               1 [:message (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestEcho-record)))

(defn ecis->RequestEcho
  "Embedded CodedInputStream to RequestEcho"
  [is]
  (serdes.core/cis->embedded cis->RequestEcho is))

(defn new-RequestEcho
  "Creates a new instance from a map, similar to map->RequestEcho except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestEcho-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestEcho-spec init))))]}
  (-> (merge RequestEcho-defaults init)
      (map->RequestEcho-record)))

(defn pb->RequestEcho
  "Protobuf to RequestEcho"
  [input]
  (cis->RequestEcho (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestEcho-meta {:type "tendermint.abci.RequestEcho" :decoder pb->RequestEcho})

;-----------------------------------------------------------------------------
; EventAttribute
;-----------------------------------------------------------------------------
(defrecord EventAttribute-record [key value index]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:key this) os)
    (serdes.core/write-String 2  {:optimize true} (:value this) os)
    (serdes.core/write-Bool 3  {:optimize true} (:index this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.EventAttribute"))

(s/def :tendermint.abci.EventAttribute/key string?)
(s/def :tendermint.abci.EventAttribute/value string?)
(s/def :tendermint.abci.EventAttribute/index boolean?)
(s/def ::EventAttribute-spec (s/keys :opt-un [:tendermint.abci.EventAttribute/key :tendermint.abci.EventAttribute/value :tendermint.abci.EventAttribute/index ]))
(def EventAttribute-defaults {:key "" :value "" :index false })

(defn cis->EventAttribute
  "CodedInputStream to EventAttribute"
  [is]
  (->> (tag-map EventAttribute-defaults
         (fn [tag index]
             (case index
               1 [:key (serdes.core/cis->String is)]
               2 [:value (serdes.core/cis->String is)]
               3 [:index (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->EventAttribute-record)))

(defn ecis->EventAttribute
  "Embedded CodedInputStream to EventAttribute"
  [is]
  (serdes.core/cis->embedded cis->EventAttribute is))

(defn new-EventAttribute
  "Creates a new instance from a map, similar to map->EventAttribute except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EventAttribute-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EventAttribute-spec init))))]}
  (-> (merge EventAttribute-defaults init)
      (map->EventAttribute-record)))

(defn pb->EventAttribute
  "Protobuf to EventAttribute"
  [input]
  (cis->EventAttribute (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EventAttribute-meta {:type "tendermint.abci.EventAttribute" :decoder pb->EventAttribute})

;-----------------------------------------------------------------------------
; ResponseEndBlock
;-----------------------------------------------------------------------------
(defrecord ResponseEndBlock-record [validator-updates consensus-param-updates events]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:validator-updates this) os)
    (serdes.core/write-embedded 2 (:consensus-param-updates this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 3 (:events this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseEndBlock"))

(s/def ::ResponseEndBlock-spec (s/keys :opt-un []))
(def ResponseEndBlock-defaults {:validator-updates [] :events [] })

(defn cis->ResponseEndBlock
  "CodedInputStream to ResponseEndBlock"
  [is]
  (->> (tag-map ResponseEndBlock-defaults
         (fn [tag index]
             (case index
               1 [:validator-updates (serdes.complex/cis->repeated ecis->ValidatorUpdate is)]
               2 [:consensus-param-updates (tendermint.types/ecis->ConsensusParams is)]
               3 [:events (serdes.complex/cis->repeated ecis->Event is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseEndBlock-record)))

(defn ecis->ResponseEndBlock
  "Embedded CodedInputStream to ResponseEndBlock"
  [is]
  (serdes.core/cis->embedded cis->ResponseEndBlock is))

(defn new-ResponseEndBlock
  "Creates a new instance from a map, similar to map->ResponseEndBlock except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseEndBlock-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseEndBlock-spec init))))]}
  (-> (merge ResponseEndBlock-defaults init)
      (cond-> (some? (get init :validator-updates)) (update :validator-updates #(map new-ValidatorUpdate %)))
      (cond-> (some? (get init :consensus-param-updates)) (update :consensus-param-updates tendermint.types/new-ConsensusParams))
      (cond-> (some? (get init :events)) (update :events #(map new-Event %)))
      (map->ResponseEndBlock-record)))

(defn pb->ResponseEndBlock
  "Protobuf to ResponseEndBlock"
  [input]
  (cis->ResponseEndBlock (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseEndBlock-meta {:type "tendermint.abci.ResponseEndBlock" :decoder pb->ResponseEndBlock})

;-----------------------------------------------------------------------------
; Request
;-----------------------------------------------------------------------------
(defrecord Request-record [value]
  pb/Writer
  (serialize [this os]
    (write-Request-value  (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.Request"))

(s/def ::Request-spec (s/keys :opt-un []))
(def Request-defaults {})

(defn cis->Request
  "CodedInputStream to Request"
  [is]
  (->> (tag-map Request-defaults
         (fn [tag index]
             (case index
               6 [:value {:begin-block (ecis->RequestBeginBlock is)}]
               5 [:value {:query (ecis->RequestQuery is)}]
               3 [:value {:info (ecis->RequestInfo is)}]
               2 [:value {:flush (ecis->RequestFlush is)}]
               9 [:value {:end-block (ecis->RequestEndBlock is)}]
               12 [:value {:offer-snapshot (ecis->RequestOfferSnapshot is)}]
               14 [:value {:apply-snapshot-chunk (ecis->RequestApplySnapshotChunk is)}]
               10 [:value {:commit (ecis->RequestCommit is)}]
               13 [:value {:load-snapshot-chunk (ecis->RequestLoadSnapshotChunk is)}]
               4 [:value {:init-chain (ecis->RequestInitChain is)}]
               7 [:value {:check-tx (ecis->RequestCheckTx is)}]
               8 [:value {:deliver-tx (ecis->RequestDeliverTx is)}]
               1 [:value {:echo (ecis->RequestEcho is)}]
               11 [:value {:list-snapshots (ecis->RequestListSnapshots is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Request-record)))

(defn ecis->Request
  "Embedded CodedInputStream to Request"
  [is]
  (serdes.core/cis->embedded cis->Request is))

(defn new-Request
  "Creates a new instance from a map, similar to map->Request except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Request-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Request-spec init))))]}
  (-> (merge Request-defaults init)
      (convert-Request-value)
      (map->Request-record)))

(defn pb->Request
  "Protobuf to Request"
  [input]
  (cis->Request (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Request-meta {:type "tendermint.abci.Request" :decoder pb->Request})

;-----------------------------------------------------------------------------
; ResponseOfferSnapshot
;-----------------------------------------------------------------------------
(defrecord ResponseOfferSnapshot-record [result]
  pb/Writer
  (serialize [this os]
    (write-ResponseOfferSnapshot-Result 1  {:optimize true} (:result this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseOfferSnapshot"))

(s/def :tendermint.abci.ResponseOfferSnapshot/result (s/or :keyword keyword? :int int?))
(s/def ::ResponseOfferSnapshot-spec (s/keys :opt-un [:tendermint.abci.ResponseOfferSnapshot/result ]))
(def ResponseOfferSnapshot-defaults {:result ResponseOfferSnapshot-Result-default })

(defn cis->ResponseOfferSnapshot
  "CodedInputStream to ResponseOfferSnapshot"
  [is]
  (->> (tag-map ResponseOfferSnapshot-defaults
         (fn [tag index]
             (case index
               1 [:result (cis->ResponseOfferSnapshot-Result is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseOfferSnapshot-record)))

(defn ecis->ResponseOfferSnapshot
  "Embedded CodedInputStream to ResponseOfferSnapshot"
  [is]
  (serdes.core/cis->embedded cis->ResponseOfferSnapshot is))

(defn new-ResponseOfferSnapshot
  "Creates a new instance from a map, similar to map->ResponseOfferSnapshot except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseOfferSnapshot-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseOfferSnapshot-spec init))))]}
  (-> (merge ResponseOfferSnapshot-defaults init)
      (map->ResponseOfferSnapshot-record)))

(defn pb->ResponseOfferSnapshot
  "Protobuf to ResponseOfferSnapshot"
  [input]
  (cis->ResponseOfferSnapshot (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseOfferSnapshot-meta {:type "tendermint.abci.ResponseOfferSnapshot" :decoder pb->ResponseOfferSnapshot})

;-----------------------------------------------------------------------------
; RequestFlush
;-----------------------------------------------------------------------------
(defrecord RequestFlush-record []
  pb/Writer
  (serialize [this os]
)
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestFlush"))

(s/def ::RequestFlush-spec (s/keys :opt-un []))
(def RequestFlush-defaults {})

(defn cis->RequestFlush
  "CodedInputStream to RequestFlush"
  [is]
  (->> (tag-map RequestFlush-defaults
         (fn [tag index]
             (case index
               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestFlush-record)))

(defn ecis->RequestFlush
  "Embedded CodedInputStream to RequestFlush"
  [is]
  (serdes.core/cis->embedded cis->RequestFlush is))

(defn new-RequestFlush
  "Creates a new instance from a map, similar to map->RequestFlush except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestFlush-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestFlush-spec init))))]}
  (-> (merge RequestFlush-defaults init)
      (map->RequestFlush-record)))

(defn pb->RequestFlush
  "Protobuf to RequestFlush"
  [input]
  (cis->RequestFlush (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestFlush-meta {:type "tendermint.abci.RequestFlush" :decoder pb->RequestFlush})

;-----------------------------------------------------------------------------
; RequestBeginBlock
;-----------------------------------------------------------------------------
(defrecord RequestBeginBlock-record [hash header last-commit-info byzantine-validators]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:hash this) os)
    (serdes.core/write-embedded 2 (:header this) os)
    (serdes.core/write-embedded 3 (:last-commit-info this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:byzantine-validators this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestBeginBlock"))

(s/def :tendermint.abci.RequestBeginBlock/hash bytes?)



(s/def ::RequestBeginBlock-spec (s/keys :opt-un [:tendermint.abci.RequestBeginBlock/hash ]))
(def RequestBeginBlock-defaults {:hash (byte-array 0) :byzantine-validators [] })

(defn cis->RequestBeginBlock
  "CodedInputStream to RequestBeginBlock"
  [is]
  (->> (tag-map RequestBeginBlock-defaults
         (fn [tag index]
             (case index
               1 [:hash (serdes.core/cis->Bytes is)]
               2 [:header (tendermint.types/ecis->Header is)]
               3 [:last-commit-info (ecis->LastCommitInfo is)]
               4 [:byzantine-validators (serdes.complex/cis->repeated ecis->Evidence is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestBeginBlock-record)))

(defn ecis->RequestBeginBlock
  "Embedded CodedInputStream to RequestBeginBlock"
  [is]
  (serdes.core/cis->embedded cis->RequestBeginBlock is))

(defn new-RequestBeginBlock
  "Creates a new instance from a map, similar to map->RequestBeginBlock except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestBeginBlock-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestBeginBlock-spec init))))]}
  (-> (merge RequestBeginBlock-defaults init)
      (cond-> (some? (get init :header)) (update :header tendermint.types/new-Header))
      (cond-> (some? (get init :last-commit-info)) (update :last-commit-info new-LastCommitInfo))
      (cond-> (some? (get init :byzantine-validators)) (update :byzantine-validators #(map new-Evidence %)))
      (map->RequestBeginBlock-record)))

(defn pb->RequestBeginBlock
  "Protobuf to RequestBeginBlock"
  [input]
  (cis->RequestBeginBlock (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestBeginBlock-meta {:type "tendermint.abci.RequestBeginBlock" :decoder pb->RequestBeginBlock})

;-----------------------------------------------------------------------------
; ResponseDeliverTx
;-----------------------------------------------------------------------------
(defrecord ResponseDeliverTx-record [code data log info gas-wanted gas-used events codespace]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt32 1  {:optimize true} (:code this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:data this) os)
    (serdes.core/write-String 3  {:optimize true} (:log this) os)
    (serdes.core/write-String 4  {:optimize true} (:info this) os)
    (serdes.core/write-Int64 5  {:optimize true} (:gas-wanted this) os)
    (serdes.core/write-Int64 6  {:optimize true} (:gas-used this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 7 (:events this) os)
    (serdes.core/write-String 8  {:optimize true} (:codespace this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseDeliverTx"))

(s/def :tendermint.abci.ResponseDeliverTx/code int?)
(s/def :tendermint.abci.ResponseDeliverTx/data bytes?)
(s/def :tendermint.abci.ResponseDeliverTx/log string?)
(s/def :tendermint.abci.ResponseDeliverTx/info string?)
(s/def :tendermint.abci.ResponseDeliverTx/gas-wanted int?)
(s/def :tendermint.abci.ResponseDeliverTx/gas-used int?)

(s/def :tendermint.abci.ResponseDeliverTx/codespace string?)
(s/def ::ResponseDeliverTx-spec (s/keys :opt-un [:tendermint.abci.ResponseDeliverTx/code :tendermint.abci.ResponseDeliverTx/data :tendermint.abci.ResponseDeliverTx/log :tendermint.abci.ResponseDeliverTx/info :tendermint.abci.ResponseDeliverTx/gas-wanted :tendermint.abci.ResponseDeliverTx/gas-used :tendermint.abci.ResponseDeliverTx/codespace ]))
(def ResponseDeliverTx-defaults {:code 0 :data (byte-array 0) :log "" :info "" :gas-wanted 0 :gas-used 0 :events [] :codespace "" })

(defn cis->ResponseDeliverTx
  "CodedInputStream to ResponseDeliverTx"
  [is]
  (->> (tag-map ResponseDeliverTx-defaults
         (fn [tag index]
             (case index
               1 [:code (serdes.core/cis->UInt32 is)]
               2 [:data (serdes.core/cis->Bytes is)]
               3 [:log (serdes.core/cis->String is)]
               4 [:info (serdes.core/cis->String is)]
               5 [:gas-wanted (serdes.core/cis->Int64 is)]
               6 [:gas-used (serdes.core/cis->Int64 is)]
               7 [:events (serdes.complex/cis->repeated ecis->Event is)]
               8 [:codespace (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseDeliverTx-record)))

(defn ecis->ResponseDeliverTx
  "Embedded CodedInputStream to ResponseDeliverTx"
  [is]
  (serdes.core/cis->embedded cis->ResponseDeliverTx is))

(defn new-ResponseDeliverTx
  "Creates a new instance from a map, similar to map->ResponseDeliverTx except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseDeliverTx-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseDeliverTx-spec init))))]}
  (-> (merge ResponseDeliverTx-defaults init)
      (cond-> (some? (get init :events)) (update :events #(map new-Event %)))
      (map->ResponseDeliverTx-record)))

(defn pb->ResponseDeliverTx
  "Protobuf to ResponseDeliverTx"
  [input]
  (cis->ResponseDeliverTx (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseDeliverTx-meta {:type "tendermint.abci.ResponseDeliverTx" :decoder pb->ResponseDeliverTx})

;-----------------------------------------------------------------------------
; ResponseEcho
;-----------------------------------------------------------------------------
(defrecord ResponseEcho-record [message]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:message this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseEcho"))

(s/def :tendermint.abci.ResponseEcho/message string?)
(s/def ::ResponseEcho-spec (s/keys :opt-un [:tendermint.abci.ResponseEcho/message ]))
(def ResponseEcho-defaults {:message "" })

(defn cis->ResponseEcho
  "CodedInputStream to ResponseEcho"
  [is]
  (->> (tag-map ResponseEcho-defaults
         (fn [tag index]
             (case index
               1 [:message (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseEcho-record)))

(defn ecis->ResponseEcho
  "Embedded CodedInputStream to ResponseEcho"
  [is]
  (serdes.core/cis->embedded cis->ResponseEcho is))

(defn new-ResponseEcho
  "Creates a new instance from a map, similar to map->ResponseEcho except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseEcho-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseEcho-spec init))))]}
  (-> (merge ResponseEcho-defaults init)
      (map->ResponseEcho-record)))

(defn pb->ResponseEcho
  "Protobuf to ResponseEcho"
  [input]
  (cis->ResponseEcho (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseEcho-meta {:type "tendermint.abci.ResponseEcho" :decoder pb->ResponseEcho})

;-----------------------------------------------------------------------------
; RequestCheckTx
;-----------------------------------------------------------------------------
(defrecord RequestCheckTx-record [tx type]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:tx this) os)
    (write-CheckTxType 2  {:optimize true} (:type this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestCheckTx"))

(s/def :tendermint.abci.RequestCheckTx/tx bytes?)
(s/def :tendermint.abci.RequestCheckTx/type (s/or :keyword keyword? :int int?))
(s/def ::RequestCheckTx-spec (s/keys :opt-un [:tendermint.abci.RequestCheckTx/tx :tendermint.abci.RequestCheckTx/type ]))
(def RequestCheckTx-defaults {:tx (byte-array 0) :type CheckTxType-default })

(defn cis->RequestCheckTx
  "CodedInputStream to RequestCheckTx"
  [is]
  (->> (tag-map RequestCheckTx-defaults
         (fn [tag index]
             (case index
               1 [:tx (serdes.core/cis->Bytes is)]
               2 [:type (cis->CheckTxType is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestCheckTx-record)))

(defn ecis->RequestCheckTx
  "Embedded CodedInputStream to RequestCheckTx"
  [is]
  (serdes.core/cis->embedded cis->RequestCheckTx is))

(defn new-RequestCheckTx
  "Creates a new instance from a map, similar to map->RequestCheckTx except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestCheckTx-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestCheckTx-spec init))))]}
  (-> (merge RequestCheckTx-defaults init)
      (map->RequestCheckTx-record)))

(defn pb->RequestCheckTx
  "Protobuf to RequestCheckTx"
  [input]
  (cis->RequestCheckTx (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestCheckTx-meta {:type "tendermint.abci.RequestCheckTx" :decoder pb->RequestCheckTx})

;-----------------------------------------------------------------------------
; ResponseQuery
;-----------------------------------------------------------------------------
(defrecord ResponseQuery-record [proof-ops index height key info log value code codespace]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 8 (:proof-ops this) os)
    (serdes.core/write-Int64 5  {:optimize true} (:index this) os)
    (serdes.core/write-Int64 9  {:optimize true} (:height this) os)
    (serdes.core/write-Bytes 6  {:optimize true} (:key this) os)
    (serdes.core/write-String 4  {:optimize true} (:info this) os)
    (serdes.core/write-String 3  {:optimize true} (:log this) os)
    (serdes.core/write-Bytes 7  {:optimize true} (:value this) os)
    (serdes.core/write-UInt32 1  {:optimize true} (:code this) os)
    (serdes.core/write-String 10  {:optimize true} (:codespace this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseQuery"))

(s/def :tendermint.abci.ResponseQuery/index int?)
(s/def :tendermint.abci.ResponseQuery/height int?)
(s/def :tendermint.abci.ResponseQuery/key bytes?)
(s/def :tendermint.abci.ResponseQuery/info string?)
(s/def :tendermint.abci.ResponseQuery/log string?)
(s/def :tendermint.abci.ResponseQuery/value bytes?)
(s/def :tendermint.abci.ResponseQuery/code int?)
(s/def :tendermint.abci.ResponseQuery/codespace string?)
(s/def ::ResponseQuery-spec (s/keys :opt-un [:tendermint.abci.ResponseQuery/index :tendermint.abci.ResponseQuery/height :tendermint.abci.ResponseQuery/key :tendermint.abci.ResponseQuery/info :tendermint.abci.ResponseQuery/log :tendermint.abci.ResponseQuery/value :tendermint.abci.ResponseQuery/code :tendermint.abci.ResponseQuery/codespace ]))
(def ResponseQuery-defaults {:index 0 :height 0 :key (byte-array 0) :info "" :log "" :value (byte-array 0) :code 0 :codespace "" })

(defn cis->ResponseQuery
  "CodedInputStream to ResponseQuery"
  [is]
  (->> (tag-map ResponseQuery-defaults
         (fn [tag index]
             (case index
               8 [:proof-ops (tendermint.crypto/ecis->ProofOps is)]
               5 [:index (serdes.core/cis->Int64 is)]
               9 [:height (serdes.core/cis->Int64 is)]
               6 [:key (serdes.core/cis->Bytes is)]
               4 [:info (serdes.core/cis->String is)]
               3 [:log (serdes.core/cis->String is)]
               7 [:value (serdes.core/cis->Bytes is)]
               1 [:code (serdes.core/cis->UInt32 is)]
               10 [:codespace (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseQuery-record)))

(defn ecis->ResponseQuery
  "Embedded CodedInputStream to ResponseQuery"
  [is]
  (serdes.core/cis->embedded cis->ResponseQuery is))

(defn new-ResponseQuery
  "Creates a new instance from a map, similar to map->ResponseQuery except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseQuery-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseQuery-spec init))))]}
  (-> (merge ResponseQuery-defaults init)
      (cond-> (some? (get init :proof-ops)) (update :proof-ops tendermint.crypto/new-ProofOps))
      (map->ResponseQuery-record)))

(defn pb->ResponseQuery
  "Protobuf to ResponseQuery"
  [input]
  (cis->ResponseQuery (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseQuery-meta {:type "tendermint.abci.ResponseQuery" :decoder pb->ResponseQuery})

;-----------------------------------------------------------------------------
; VoteInfo
;-----------------------------------------------------------------------------
(defrecord VoteInfo-record [validator signed-last-block]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:validator this) os)
    (serdes.core/write-Bool 2  {:optimize true} (:signed-last-block this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.VoteInfo"))

(s/def :tendermint.abci.VoteInfo/signed-last-block boolean?)
(s/def ::VoteInfo-spec (s/keys :opt-un [:tendermint.abci.VoteInfo/signed-last-block ]))
(def VoteInfo-defaults {:signed-last-block false })

(defn cis->VoteInfo
  "CodedInputStream to VoteInfo"
  [is]
  (->> (tag-map VoteInfo-defaults
         (fn [tag index]
             (case index
               1 [:validator (ecis->Validator is)]
               2 [:signed-last-block (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->VoteInfo-record)))

(defn ecis->VoteInfo
  "Embedded CodedInputStream to VoteInfo"
  [is]
  (serdes.core/cis->embedded cis->VoteInfo is))

(defn new-VoteInfo
  "Creates a new instance from a map, similar to map->VoteInfo except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::VoteInfo-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::VoteInfo-spec init))))]}
  (-> (merge VoteInfo-defaults init)
      (cond-> (some? (get init :validator)) (update :validator new-Validator))
      (map->VoteInfo-record)))

(defn pb->VoteInfo
  "Protobuf to VoteInfo"
  [input]
  (cis->VoteInfo (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record VoteInfo-meta {:type "tendermint.abci.VoteInfo" :decoder pb->VoteInfo})

;-----------------------------------------------------------------------------
; Evidence
;-----------------------------------------------------------------------------
(defrecord Evidence-record [type validator height time total-voting-power]
  pb/Writer
  (serialize [this os]
    (write-EvidenceType 1  {:optimize true} (:type this) os)
    (serdes.core/write-embedded 2 (:validator this) os)
    (serdes.core/write-Int64 3  {:optimize true} (:height this) os)
    (serdes.core/write-embedded 4 (:time this) os)
    (serdes.core/write-Int64 5  {:optimize true} (:total-voting-power this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.Evidence"))

(s/def :tendermint.abci.Evidence/type (s/or :keyword keyword? :int int?))

(s/def :tendermint.abci.Evidence/height int?)

(s/def :tendermint.abci.Evidence/total-voting-power int?)
(s/def ::Evidence-spec (s/keys :opt-un [:tendermint.abci.Evidence/type :tendermint.abci.Evidence/height :tendermint.abci.Evidence/total-voting-power ]))
(def Evidence-defaults {:type EvidenceType-default :height 0 :total-voting-power 0 })

(defn cis->Evidence
  "CodedInputStream to Evidence"
  [is]
  (->> (tag-map Evidence-defaults
         (fn [tag index]
             (case index
               1 [:type (cis->EvidenceType is)]
               2 [:validator (ecis->Validator is)]
               3 [:height (serdes.core/cis->Int64 is)]
               4 [:time (com.google.protobuf/ecis->Timestamp is)]
               5 [:total-voting-power (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Evidence-record)))

(defn ecis->Evidence
  "Embedded CodedInputStream to Evidence"
  [is]
  (serdes.core/cis->embedded cis->Evidence is))

(defn new-Evidence
  "Creates a new instance from a map, similar to map->Evidence except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Evidence-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Evidence-spec init))))]}
  (-> (merge Evidence-defaults init)
      (cond-> (some? (get init :validator)) (update :validator new-Validator))
      (cond-> (some? (get init :time)) (update :time com.google.protobuf/new-Timestamp))
      (map->Evidence-record)))

(defn pb->Evidence
  "Protobuf to Evidence"
  [input]
  (cis->Evidence (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Evidence-meta {:type "tendermint.abci.Evidence" :decoder pb->Evidence})

;-----------------------------------------------------------------------------
; ResponseException
;-----------------------------------------------------------------------------
(defrecord ResponseException-record [error]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:error this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseException"))

(s/def :tendermint.abci.ResponseException/error string?)
(s/def ::ResponseException-spec (s/keys :opt-un [:tendermint.abci.ResponseException/error ]))
(def ResponseException-defaults {:error "" })

(defn cis->ResponseException
  "CodedInputStream to ResponseException"
  [is]
  (->> (tag-map ResponseException-defaults
         (fn [tag index]
             (case index
               1 [:error (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseException-record)))

(defn ecis->ResponseException
  "Embedded CodedInputStream to ResponseException"
  [is]
  (serdes.core/cis->embedded cis->ResponseException is))

(defn new-ResponseException
  "Creates a new instance from a map, similar to map->ResponseException except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseException-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseException-spec init))))]}
  (-> (merge ResponseException-defaults init)
      (map->ResponseException-record)))

(defn pb->ResponseException
  "Protobuf to ResponseException"
  [input]
  (cis->ResponseException (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseException-meta {:type "tendermint.abci.ResponseException" :decoder pb->ResponseException})

;-----------------------------------------------------------------------------
; Event
;-----------------------------------------------------------------------------
(defrecord Event-record [type attributes]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:type this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:attributes this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.Event"))

(s/def :tendermint.abci.Event/type string?)

(s/def ::Event-spec (s/keys :opt-un [:tendermint.abci.Event/type ]))
(def Event-defaults {:type "" :attributes [] })

(defn cis->Event
  "CodedInputStream to Event"
  [is]
  (->> (tag-map Event-defaults
         (fn [tag index]
             (case index
               1 [:type (serdes.core/cis->String is)]
               2 [:attributes (serdes.complex/cis->repeated ecis->EventAttribute is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Event-record)))

(defn ecis->Event
  "Embedded CodedInputStream to Event"
  [is]
  (serdes.core/cis->embedded cis->Event is))

(defn new-Event
  "Creates a new instance from a map, similar to map->Event except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Event-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Event-spec init))))]}
  (-> (merge Event-defaults init)
      (cond-> (some? (get init :attributes)) (update :attributes #(map new-EventAttribute %)))
      (map->Event-record)))

(defn pb->Event
  "Protobuf to Event"
  [input]
  (cis->Event (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Event-meta {:type "tendermint.abci.Event" :decoder pb->Event})

;-----------------------------------------------------------------------------
; RequestEndBlock
;-----------------------------------------------------------------------------
(defrecord RequestEndBlock-record [height]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int64 1  {:optimize true} (:height this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestEndBlock"))

(s/def :tendermint.abci.RequestEndBlock/height int?)
(s/def ::RequestEndBlock-spec (s/keys :opt-un [:tendermint.abci.RequestEndBlock/height ]))
(def RequestEndBlock-defaults {:height 0 })

(defn cis->RequestEndBlock
  "CodedInputStream to RequestEndBlock"
  [is]
  (->> (tag-map RequestEndBlock-defaults
         (fn [tag index]
             (case index
               1 [:height (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestEndBlock-record)))

(defn ecis->RequestEndBlock
  "Embedded CodedInputStream to RequestEndBlock"
  [is]
  (serdes.core/cis->embedded cis->RequestEndBlock is))

(defn new-RequestEndBlock
  "Creates a new instance from a map, similar to map->RequestEndBlock except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestEndBlock-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestEndBlock-spec init))))]}
  (-> (merge RequestEndBlock-defaults init)
      (map->RequestEndBlock-record)))

(defn pb->RequestEndBlock
  "Protobuf to RequestEndBlock"
  [input]
  (cis->RequestEndBlock (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestEndBlock-meta {:type "tendermint.abci.RequestEndBlock" :decoder pb->RequestEndBlock})

;-----------------------------------------------------------------------------
; RequestListSnapshots
;-----------------------------------------------------------------------------
(defrecord RequestListSnapshots-record []
  pb/Writer
  (serialize [this os]
)
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestListSnapshots"))

(s/def ::RequestListSnapshots-spec (s/keys :opt-un []))
(def RequestListSnapshots-defaults {})

(defn cis->RequestListSnapshots
  "CodedInputStream to RequestListSnapshots"
  [is]
  (->> (tag-map RequestListSnapshots-defaults
         (fn [tag index]
             (case index
               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestListSnapshots-record)))

(defn ecis->RequestListSnapshots
  "Embedded CodedInputStream to RequestListSnapshots"
  [is]
  (serdes.core/cis->embedded cis->RequestListSnapshots is))

(defn new-RequestListSnapshots
  "Creates a new instance from a map, similar to map->RequestListSnapshots except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestListSnapshots-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestListSnapshots-spec init))))]}
  (-> (merge RequestListSnapshots-defaults init)
      (map->RequestListSnapshots-record)))

(defn pb->RequestListSnapshots
  "Protobuf to RequestListSnapshots"
  [input]
  (cis->RequestListSnapshots (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestListSnapshots-meta {:type "tendermint.abci.RequestListSnapshots" :decoder pb->RequestListSnapshots})

;-----------------------------------------------------------------------------
; Response
;-----------------------------------------------------------------------------
(defrecord Response-record [value]
  pb/Writer
  (serialize [this os]
    (write-Response-value  (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.Response"))

(s/def ::Response-spec (s/keys :opt-un []))
(def Response-defaults {})

(defn cis->Response
  "CodedInputStream to Response"
  [is]
  (->> (tag-map Response-defaults
         (fn [tag index]
             (case index
               7 [:value {:begin-block (ecis->ResponseBeginBlock is)}]
               6 [:value {:query (ecis->ResponseQuery is)}]
               4 [:value {:info (ecis->ResponseInfo is)}]
               1 [:value {:exception (ecis->ResponseException is)}]
               3 [:value {:flush (ecis->ResponseFlush is)}]
               10 [:value {:end-block (ecis->ResponseEndBlock is)}]
               13 [:value {:offer-snapshot (ecis->ResponseOfferSnapshot is)}]
               15 [:value {:apply-snapshot-chunk (ecis->ResponseApplySnapshotChunk is)}]
               11 [:value {:commit (ecis->ResponseCommit is)}]
               14 [:value {:load-snapshot-chunk (ecis->ResponseLoadSnapshotChunk is)}]
               5 [:value {:init-chain (ecis->ResponseInitChain is)}]
               8 [:value {:check-tx (ecis->ResponseCheckTx is)}]
               9 [:value {:deliver-tx (ecis->ResponseDeliverTx is)}]
               2 [:value {:echo (ecis->ResponseEcho is)}]
               12 [:value {:list-snapshots (ecis->ResponseListSnapshots is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Response-record)))

(defn ecis->Response
  "Embedded CodedInputStream to Response"
  [is]
  (serdes.core/cis->embedded cis->Response is))

(defn new-Response
  "Creates a new instance from a map, similar to map->Response except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Response-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Response-spec init))))]}
  (-> (merge Response-defaults init)
      (convert-Response-value)
      (map->Response-record)))

(defn pb->Response
  "Protobuf to Response"
  [input]
  (cis->Response (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Response-meta {:type "tendermint.abci.Response" :decoder pb->Response})

;-----------------------------------------------------------------------------
; RequestQuery
;-----------------------------------------------------------------------------
(defrecord RequestQuery-record [data path height prove]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:data this) os)
    (serdes.core/write-String 2  {:optimize true} (:path this) os)
    (serdes.core/write-Int64 3  {:optimize true} (:height this) os)
    (serdes.core/write-Bool 4  {:optimize true} (:prove this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestQuery"))

(s/def :tendermint.abci.RequestQuery/data bytes?)
(s/def :tendermint.abci.RequestQuery/path string?)
(s/def :tendermint.abci.RequestQuery/height int?)
(s/def :tendermint.abci.RequestQuery/prove boolean?)
(s/def ::RequestQuery-spec (s/keys :opt-un [:tendermint.abci.RequestQuery/data :tendermint.abci.RequestQuery/path :tendermint.abci.RequestQuery/height :tendermint.abci.RequestQuery/prove ]))
(def RequestQuery-defaults {:data (byte-array 0) :path "" :height 0 :prove false })

(defn cis->RequestQuery
  "CodedInputStream to RequestQuery"
  [is]
  (->> (tag-map RequestQuery-defaults
         (fn [tag index]
             (case index
               1 [:data (serdes.core/cis->Bytes is)]
               2 [:path (serdes.core/cis->String is)]
               3 [:height (serdes.core/cis->Int64 is)]
               4 [:prove (serdes.core/cis->Bool is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestQuery-record)))

(defn ecis->RequestQuery
  "Embedded CodedInputStream to RequestQuery"
  [is]
  (serdes.core/cis->embedded cis->RequestQuery is))

(defn new-RequestQuery
  "Creates a new instance from a map, similar to map->RequestQuery except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestQuery-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestQuery-spec init))))]}
  (-> (merge RequestQuery-defaults init)
      (map->RequestQuery-record)))

(defn pb->RequestQuery
  "Protobuf to RequestQuery"
  [input]
  (cis->RequestQuery (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestQuery-meta {:type "tendermint.abci.RequestQuery" :decoder pb->RequestQuery})

;-----------------------------------------------------------------------------
; RequestOfferSnapshot
;-----------------------------------------------------------------------------
(defrecord RequestOfferSnapshot-record [snapshot app-hash]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:snapshot this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:app-hash this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestOfferSnapshot"))

(s/def :tendermint.abci.RequestOfferSnapshot/app-hash bytes?)
(s/def ::RequestOfferSnapshot-spec (s/keys :opt-un [:tendermint.abci.RequestOfferSnapshot/app-hash ]))
(def RequestOfferSnapshot-defaults {:app-hash (byte-array 0) })

(defn cis->RequestOfferSnapshot
  "CodedInputStream to RequestOfferSnapshot"
  [is]
  (->> (tag-map RequestOfferSnapshot-defaults
         (fn [tag index]
             (case index
               1 [:snapshot (ecis->Snapshot is)]
               2 [:app-hash (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestOfferSnapshot-record)))

(defn ecis->RequestOfferSnapshot
  "Embedded CodedInputStream to RequestOfferSnapshot"
  [is]
  (serdes.core/cis->embedded cis->RequestOfferSnapshot is))

(defn new-RequestOfferSnapshot
  "Creates a new instance from a map, similar to map->RequestOfferSnapshot except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestOfferSnapshot-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestOfferSnapshot-spec init))))]}
  (-> (merge RequestOfferSnapshot-defaults init)
      (cond-> (some? (get init :snapshot)) (update :snapshot new-Snapshot))
      (map->RequestOfferSnapshot-record)))

(defn pb->RequestOfferSnapshot
  "Protobuf to RequestOfferSnapshot"
  [input]
  (cis->RequestOfferSnapshot (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestOfferSnapshot-meta {:type "tendermint.abci.RequestOfferSnapshot" :decoder pb->RequestOfferSnapshot})

;-----------------------------------------------------------------------------
; LastCommitInfo
;-----------------------------------------------------------------------------
(defrecord LastCommitInfo-record [round votes]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:round this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:votes this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.LastCommitInfo"))

(s/def :tendermint.abci.LastCommitInfo/round int?)

(s/def ::LastCommitInfo-spec (s/keys :opt-un [:tendermint.abci.LastCommitInfo/round ]))
(def LastCommitInfo-defaults {:round 0 :votes [] })

(defn cis->LastCommitInfo
  "CodedInputStream to LastCommitInfo"
  [is]
  (->> (tag-map LastCommitInfo-defaults
         (fn [tag index]
             (case index
               1 [:round (serdes.core/cis->Int32 is)]
               2 [:votes (serdes.complex/cis->repeated ecis->VoteInfo is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->LastCommitInfo-record)))

(defn ecis->LastCommitInfo
  "Embedded CodedInputStream to LastCommitInfo"
  [is]
  (serdes.core/cis->embedded cis->LastCommitInfo is))

(defn new-LastCommitInfo
  "Creates a new instance from a map, similar to map->LastCommitInfo except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::LastCommitInfo-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::LastCommitInfo-spec init))))]}
  (-> (merge LastCommitInfo-defaults init)
      (cond-> (some? (get init :votes)) (update :votes #(map new-VoteInfo %)))
      (map->LastCommitInfo-record)))

(defn pb->LastCommitInfo
  "Protobuf to LastCommitInfo"
  [input]
  (cis->LastCommitInfo (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record LastCommitInfo-meta {:type "tendermint.abci.LastCommitInfo" :decoder pb->LastCommitInfo})

;-----------------------------------------------------------------------------
; RequestInitChain
;-----------------------------------------------------------------------------
(defrecord RequestInitChain-record [time chain-id consensus-params validators app-state-bytes initial-height]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:time this) os)
    (serdes.core/write-String 2  {:optimize true} (:chain-id this) os)
    (serdes.core/write-embedded 3 (:consensus-params this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:validators this) os)
    (serdes.core/write-Bytes 5  {:optimize true} (:app-state-bytes this) os)
    (serdes.core/write-Int64 6  {:optimize true} (:initial-height this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestInitChain"))

(s/def :tendermint.abci.RequestInitChain/chain-id string?)


(s/def :tendermint.abci.RequestInitChain/app-state-bytes bytes?)
(s/def :tendermint.abci.RequestInitChain/initial-height int?)
(s/def ::RequestInitChain-spec (s/keys :opt-un [:tendermint.abci.RequestInitChain/chain-id :tendermint.abci.RequestInitChain/app-state-bytes :tendermint.abci.RequestInitChain/initial-height ]))
(def RequestInitChain-defaults {:chain-id "" :validators [] :app-state-bytes (byte-array 0) :initial-height 0 })

(defn cis->RequestInitChain
  "CodedInputStream to RequestInitChain"
  [is]
  (->> (tag-map RequestInitChain-defaults
         (fn [tag index]
             (case index
               1 [:time (com.google.protobuf/ecis->Timestamp is)]
               2 [:chain-id (serdes.core/cis->String is)]
               3 [:consensus-params (tendermint.types/ecis->ConsensusParams is)]
               4 [:validators (serdes.complex/cis->repeated ecis->ValidatorUpdate is)]
               5 [:app-state-bytes (serdes.core/cis->Bytes is)]
               6 [:initial-height (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestInitChain-record)))

(defn ecis->RequestInitChain
  "Embedded CodedInputStream to RequestInitChain"
  [is]
  (serdes.core/cis->embedded cis->RequestInitChain is))

(defn new-RequestInitChain
  "Creates a new instance from a map, similar to map->RequestInitChain except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestInitChain-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestInitChain-spec init))))]}
  (-> (merge RequestInitChain-defaults init)
      (cond-> (some? (get init :time)) (update :time com.google.protobuf/new-Timestamp))
      (cond-> (some? (get init :consensus-params)) (update :consensus-params tendermint.types/new-ConsensusParams))
      (cond-> (some? (get init :validators)) (update :validators #(map new-ValidatorUpdate %)))
      (map->RequestInitChain-record)))

(defn pb->RequestInitChain
  "Protobuf to RequestInitChain"
  [input]
  (cis->RequestInitChain (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestInitChain-meta {:type "tendermint.abci.RequestInitChain" :decoder pb->RequestInitChain})

;-----------------------------------------------------------------------------
; Snapshot
;-----------------------------------------------------------------------------
(defrecord Snapshot-record [height format chunks hash metadata]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt64 1  {:optimize true} (:height this) os)
    (serdes.core/write-UInt32 2  {:optimize true} (:format this) os)
    (serdes.core/write-UInt32 3  {:optimize true} (:chunks this) os)
    (serdes.core/write-Bytes 4  {:optimize true} (:hash this) os)
    (serdes.core/write-Bytes 5  {:optimize true} (:metadata this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.Snapshot"))

(s/def :tendermint.abci.Snapshot/height int?)
(s/def :tendermint.abci.Snapshot/format int?)
(s/def :tendermint.abci.Snapshot/chunks int?)
(s/def :tendermint.abci.Snapshot/hash bytes?)
(s/def :tendermint.abci.Snapshot/metadata bytes?)
(s/def ::Snapshot-spec (s/keys :opt-un [:tendermint.abci.Snapshot/height :tendermint.abci.Snapshot/format :tendermint.abci.Snapshot/chunks :tendermint.abci.Snapshot/hash :tendermint.abci.Snapshot/metadata ]))
(def Snapshot-defaults {:height 0 :format 0 :chunks 0 :hash (byte-array 0) :metadata (byte-array 0) })

(defn cis->Snapshot
  "CodedInputStream to Snapshot"
  [is]
  (->> (tag-map Snapshot-defaults
         (fn [tag index]
             (case index
               1 [:height (serdes.core/cis->UInt64 is)]
               2 [:format (serdes.core/cis->UInt32 is)]
               3 [:chunks (serdes.core/cis->UInt32 is)]
               4 [:hash (serdes.core/cis->Bytes is)]
               5 [:metadata (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Snapshot-record)))

(defn ecis->Snapshot
  "Embedded CodedInputStream to Snapshot"
  [is]
  (serdes.core/cis->embedded cis->Snapshot is))

(defn new-Snapshot
  "Creates a new instance from a map, similar to map->Snapshot except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Snapshot-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Snapshot-spec init))))]}
  (-> (merge Snapshot-defaults init)
      (map->Snapshot-record)))

(defn pb->Snapshot
  "Protobuf to Snapshot"
  [input]
  (cis->Snapshot (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Snapshot-meta {:type "tendermint.abci.Snapshot" :decoder pb->Snapshot})

;-----------------------------------------------------------------------------
; ResponseLoadSnapshotChunk
;-----------------------------------------------------------------------------
(defrecord ResponseLoadSnapshotChunk-record [chunk]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:chunk this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseLoadSnapshotChunk"))

(s/def :tendermint.abci.ResponseLoadSnapshotChunk/chunk bytes?)
(s/def ::ResponseLoadSnapshotChunk-spec (s/keys :opt-un [:tendermint.abci.ResponseLoadSnapshotChunk/chunk ]))
(def ResponseLoadSnapshotChunk-defaults {:chunk (byte-array 0) })

(defn cis->ResponseLoadSnapshotChunk
  "CodedInputStream to ResponseLoadSnapshotChunk"
  [is]
  (->> (tag-map ResponseLoadSnapshotChunk-defaults
         (fn [tag index]
             (case index
               1 [:chunk (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseLoadSnapshotChunk-record)))

(defn ecis->ResponseLoadSnapshotChunk
  "Embedded CodedInputStream to ResponseLoadSnapshotChunk"
  [is]
  (serdes.core/cis->embedded cis->ResponseLoadSnapshotChunk is))

(defn new-ResponseLoadSnapshotChunk
  "Creates a new instance from a map, similar to map->ResponseLoadSnapshotChunk except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseLoadSnapshotChunk-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseLoadSnapshotChunk-spec init))))]}
  (-> (merge ResponseLoadSnapshotChunk-defaults init)
      (map->ResponseLoadSnapshotChunk-record)))

(defn pb->ResponseLoadSnapshotChunk
  "Protobuf to ResponseLoadSnapshotChunk"
  [input]
  (cis->ResponseLoadSnapshotChunk (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseLoadSnapshotChunk-meta {:type "tendermint.abci.ResponseLoadSnapshotChunk" :decoder pb->ResponseLoadSnapshotChunk})

;-----------------------------------------------------------------------------
; ValidatorUpdate
;-----------------------------------------------------------------------------
(defrecord ValidatorUpdate-record [pub-key power]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:pub-key this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:power this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ValidatorUpdate"))

(s/def :tendermint.abci.ValidatorUpdate/power int?)
(s/def ::ValidatorUpdate-spec (s/keys :opt-un [:tendermint.abci.ValidatorUpdate/power ]))
(def ValidatorUpdate-defaults {:power 0 })

(defn cis->ValidatorUpdate
  "CodedInputStream to ValidatorUpdate"
  [is]
  (->> (tag-map ValidatorUpdate-defaults
         (fn [tag index]
             (case index
               1 [:pub-key (tendermint.crypto/ecis->PublicKey is)]
               2 [:power (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ValidatorUpdate-record)))

(defn ecis->ValidatorUpdate
  "Embedded CodedInputStream to ValidatorUpdate"
  [is]
  (serdes.core/cis->embedded cis->ValidatorUpdate is))

(defn new-ValidatorUpdate
  "Creates a new instance from a map, similar to map->ValidatorUpdate except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ValidatorUpdate-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ValidatorUpdate-spec init))))]}
  (-> (merge ValidatorUpdate-defaults init)
      (cond-> (some? (get init :pub-key)) (update :pub-key tendermint.crypto/new-PublicKey))
      (map->ValidatorUpdate-record)))

(defn pb->ValidatorUpdate
  "Protobuf to ValidatorUpdate"
  [input]
  (cis->ValidatorUpdate (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ValidatorUpdate-meta {:type "tendermint.abci.ValidatorUpdate" :decoder pb->ValidatorUpdate})

;-----------------------------------------------------------------------------
; TxResult
;-----------------------------------------------------------------------------
(defrecord TxResult-record [height index tx result]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int64 1  {:optimize true} (:height this) os)
    (serdes.core/write-UInt32 2  {:optimize true} (:index this) os)
    (serdes.core/write-Bytes 3  {:optimize true} (:tx this) os)
    (serdes.core/write-embedded 4 (:result this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.TxResult"))

(s/def :tendermint.abci.TxResult/height int?)
(s/def :tendermint.abci.TxResult/index int?)
(s/def :tendermint.abci.TxResult/tx bytes?)

(s/def ::TxResult-spec (s/keys :opt-un [:tendermint.abci.TxResult/height :tendermint.abci.TxResult/index :tendermint.abci.TxResult/tx ]))
(def TxResult-defaults {:height 0 :index 0 :tx (byte-array 0) })

(defn cis->TxResult
  "CodedInputStream to TxResult"
  [is]
  (->> (tag-map TxResult-defaults
         (fn [tag index]
             (case index
               1 [:height (serdes.core/cis->Int64 is)]
               2 [:index (serdes.core/cis->UInt32 is)]
               3 [:tx (serdes.core/cis->Bytes is)]
               4 [:result (ecis->ResponseDeliverTx is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->TxResult-record)))

(defn ecis->TxResult
  "Embedded CodedInputStream to TxResult"
  [is]
  (serdes.core/cis->embedded cis->TxResult is))

(defn new-TxResult
  "Creates a new instance from a map, similar to map->TxResult except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TxResult-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TxResult-spec init))))]}
  (-> (merge TxResult-defaults init)
      (cond-> (some? (get init :result)) (update :result new-ResponseDeliverTx))
      (map->TxResult-record)))

(defn pb->TxResult
  "Protobuf to TxResult"
  [input]
  (cis->TxResult (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record TxResult-meta {:type "tendermint.abci.TxResult" :decoder pb->TxResult})

;-----------------------------------------------------------------------------
; RequestLoadSnapshotChunk
;-----------------------------------------------------------------------------
(defrecord RequestLoadSnapshotChunk-record [height format chunk]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt64 1  {:optimize true} (:height this) os)
    (serdes.core/write-UInt32 2  {:optimize true} (:format this) os)
    (serdes.core/write-UInt32 3  {:optimize true} (:chunk this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestLoadSnapshotChunk"))

(s/def :tendermint.abci.RequestLoadSnapshotChunk/height int?)
(s/def :tendermint.abci.RequestLoadSnapshotChunk/format int?)
(s/def :tendermint.abci.RequestLoadSnapshotChunk/chunk int?)
(s/def ::RequestLoadSnapshotChunk-spec (s/keys :opt-un [:tendermint.abci.RequestLoadSnapshotChunk/height :tendermint.abci.RequestLoadSnapshotChunk/format :tendermint.abci.RequestLoadSnapshotChunk/chunk ]))
(def RequestLoadSnapshotChunk-defaults {:height 0 :format 0 :chunk 0 })

(defn cis->RequestLoadSnapshotChunk
  "CodedInputStream to RequestLoadSnapshotChunk"
  [is]
  (->> (tag-map RequestLoadSnapshotChunk-defaults
         (fn [tag index]
             (case index
               1 [:height (serdes.core/cis->UInt64 is)]
               2 [:format (serdes.core/cis->UInt32 is)]
               3 [:chunk (serdes.core/cis->UInt32 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestLoadSnapshotChunk-record)))

(defn ecis->RequestLoadSnapshotChunk
  "Embedded CodedInputStream to RequestLoadSnapshotChunk"
  [is]
  (serdes.core/cis->embedded cis->RequestLoadSnapshotChunk is))

(defn new-RequestLoadSnapshotChunk
  "Creates a new instance from a map, similar to map->RequestLoadSnapshotChunk except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestLoadSnapshotChunk-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestLoadSnapshotChunk-spec init))))]}
  (-> (merge RequestLoadSnapshotChunk-defaults init)
      (map->RequestLoadSnapshotChunk-record)))

(defn pb->RequestLoadSnapshotChunk
  "Protobuf to RequestLoadSnapshotChunk"
  [input]
  (cis->RequestLoadSnapshotChunk (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestLoadSnapshotChunk-meta {:type "tendermint.abci.RequestLoadSnapshotChunk" :decoder pb->RequestLoadSnapshotChunk})

;-----------------------------------------------------------------------------
; ResponseInitChain
;-----------------------------------------------------------------------------
(defrecord ResponseInitChain-record [consensus-params validators app-hash]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:consensus-params this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:validators this) os)
    (serdes.core/write-Bytes 3  {:optimize true} (:app-hash this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseInitChain"))

(s/def :tendermint.abci.ResponseInitChain/app-hash bytes?)
(s/def ::ResponseInitChain-spec (s/keys :opt-un [:tendermint.abci.ResponseInitChain/app-hash ]))
(def ResponseInitChain-defaults {:validators [] :app-hash (byte-array 0) })

(defn cis->ResponseInitChain
  "CodedInputStream to ResponseInitChain"
  [is]
  (->> (tag-map ResponseInitChain-defaults
         (fn [tag index]
             (case index
               1 [:consensus-params (tendermint.types/ecis->ConsensusParams is)]
               2 [:validators (serdes.complex/cis->repeated ecis->ValidatorUpdate is)]
               3 [:app-hash (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseInitChain-record)))

(defn ecis->ResponseInitChain
  "Embedded CodedInputStream to ResponseInitChain"
  [is]
  (serdes.core/cis->embedded cis->ResponseInitChain is))

(defn new-ResponseInitChain
  "Creates a new instance from a map, similar to map->ResponseInitChain except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseInitChain-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseInitChain-spec init))))]}
  (-> (merge ResponseInitChain-defaults init)
      (cond-> (some? (get init :consensus-params)) (update :consensus-params tendermint.types/new-ConsensusParams))
      (cond-> (some? (get init :validators)) (update :validators #(map new-ValidatorUpdate %)))
      (map->ResponseInitChain-record)))

(defn pb->ResponseInitChain
  "Protobuf to ResponseInitChain"
  [input]
  (cis->ResponseInitChain (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseInitChain-meta {:type "tendermint.abci.ResponseInitChain" :decoder pb->ResponseInitChain})

;-----------------------------------------------------------------------------
; RequestDeliverTx
;-----------------------------------------------------------------------------
(defrecord RequestDeliverTx-record [tx]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:tx this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestDeliverTx"))

(s/def :tendermint.abci.RequestDeliverTx/tx bytes?)
(s/def ::RequestDeliverTx-spec (s/keys :opt-un [:tendermint.abci.RequestDeliverTx/tx ]))
(def RequestDeliverTx-defaults {:tx (byte-array 0) })

(defn cis->RequestDeliverTx
  "CodedInputStream to RequestDeliverTx"
  [is]
  (->> (tag-map RequestDeliverTx-defaults
         (fn [tag index]
             (case index
               1 [:tx (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestDeliverTx-record)))

(defn ecis->RequestDeliverTx
  "Embedded CodedInputStream to RequestDeliverTx"
  [is]
  (serdes.core/cis->embedded cis->RequestDeliverTx is))

(defn new-RequestDeliverTx
  "Creates a new instance from a map, similar to map->RequestDeliverTx except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestDeliverTx-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestDeliverTx-spec init))))]}
  (-> (merge RequestDeliverTx-defaults init)
      (map->RequestDeliverTx-record)))

(defn pb->RequestDeliverTx
  "Protobuf to RequestDeliverTx"
  [input]
  (cis->RequestDeliverTx (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestDeliverTx-meta {:type "tendermint.abci.RequestDeliverTx" :decoder pb->RequestDeliverTx})

;-----------------------------------------------------------------------------
; ResponseFlush
;-----------------------------------------------------------------------------
(defrecord ResponseFlush-record []
  pb/Writer
  (serialize [this os]
)
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseFlush"))

(s/def ::ResponseFlush-spec (s/keys :opt-un []))
(def ResponseFlush-defaults {})

(defn cis->ResponseFlush
  "CodedInputStream to ResponseFlush"
  [is]
  (->> (tag-map ResponseFlush-defaults
         (fn [tag index]
             (case index
               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseFlush-record)))

(defn ecis->ResponseFlush
  "Embedded CodedInputStream to ResponseFlush"
  [is]
  (serdes.core/cis->embedded cis->ResponseFlush is))

(defn new-ResponseFlush
  "Creates a new instance from a map, similar to map->ResponseFlush except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseFlush-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseFlush-spec init))))]}
  (-> (merge ResponseFlush-defaults init)
      (map->ResponseFlush-record)))

(defn pb->ResponseFlush
  "Protobuf to ResponseFlush"
  [input]
  (cis->ResponseFlush (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseFlush-meta {:type "tendermint.abci.ResponseFlush" :decoder pb->ResponseFlush})

;-----------------------------------------------------------------------------
; ResponseInfo
;-----------------------------------------------------------------------------
(defrecord ResponseInfo-record [data version app-version last-block-height last-block-app-hash]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:data this) os)
    (serdes.core/write-String 2  {:optimize true} (:version this) os)
    (serdes.core/write-UInt64 3  {:optimize true} (:app-version this) os)
    (serdes.core/write-Int64 4  {:optimize true} (:last-block-height this) os)
    (serdes.core/write-Bytes 5  {:optimize true} (:last-block-app-hash this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseInfo"))

(s/def :tendermint.abci.ResponseInfo/data string?)
(s/def :tendermint.abci.ResponseInfo/version string?)
(s/def :tendermint.abci.ResponseInfo/app-version int?)
(s/def :tendermint.abci.ResponseInfo/last-block-height int?)
(s/def :tendermint.abci.ResponseInfo/last-block-app-hash bytes?)
(s/def ::ResponseInfo-spec (s/keys :opt-un [:tendermint.abci.ResponseInfo/data :tendermint.abci.ResponseInfo/version :tendermint.abci.ResponseInfo/app-version :tendermint.abci.ResponseInfo/last-block-height :tendermint.abci.ResponseInfo/last-block-app-hash ]))
(def ResponseInfo-defaults {:data "" :version "" :app-version 0 :last-block-height 0 :last-block-app-hash (byte-array 0) })

(defn cis->ResponseInfo
  "CodedInputStream to ResponseInfo"
  [is]
  (->> (tag-map ResponseInfo-defaults
         (fn [tag index]
             (case index
               1 [:data (serdes.core/cis->String is)]
               2 [:version (serdes.core/cis->String is)]
               3 [:app-version (serdes.core/cis->UInt64 is)]
               4 [:last-block-height (serdes.core/cis->Int64 is)]
               5 [:last-block-app-hash (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseInfo-record)))

(defn ecis->ResponseInfo
  "Embedded CodedInputStream to ResponseInfo"
  [is]
  (serdes.core/cis->embedded cis->ResponseInfo is))

(defn new-ResponseInfo
  "Creates a new instance from a map, similar to map->ResponseInfo except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseInfo-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseInfo-spec init))))]}
  (-> (merge ResponseInfo-defaults init)
      (map->ResponseInfo-record)))

(defn pb->ResponseInfo
  "Protobuf to ResponseInfo"
  [input]
  (cis->ResponseInfo (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseInfo-meta {:type "tendermint.abci.ResponseInfo" :decoder pb->ResponseInfo})

;-----------------------------------------------------------------------------
; RequestCommit
;-----------------------------------------------------------------------------
(defrecord RequestCommit-record []
  pb/Writer
  (serialize [this os]
)
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.RequestCommit"))

(s/def ::RequestCommit-spec (s/keys :opt-un []))
(def RequestCommit-defaults {})

(defn cis->RequestCommit
  "CodedInputStream to RequestCommit"
  [is]
  (->> (tag-map RequestCommit-defaults
         (fn [tag index]
             (case index
               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RequestCommit-record)))

(defn ecis->RequestCommit
  "Embedded CodedInputStream to RequestCommit"
  [is]
  (serdes.core/cis->embedded cis->RequestCommit is))

(defn new-RequestCommit
  "Creates a new instance from a map, similar to map->RequestCommit except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RequestCommit-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RequestCommit-spec init))))]}
  (-> (merge RequestCommit-defaults init)
      (map->RequestCommit-record)))

(defn pb->RequestCommit
  "Protobuf to RequestCommit"
  [input]
  (cis->RequestCommit (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RequestCommit-meta {:type "tendermint.abci.RequestCommit" :decoder pb->RequestCommit})

;-----------------------------------------------------------------------------
; ResponseCommit
;-----------------------------------------------------------------------------
(defrecord ResponseCommit-record [data retain-height]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 2  {:optimize true} (:data this) os)
    (serdes.core/write-Int64 3  {:optimize true} (:retain-height this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseCommit"))

(s/def :tendermint.abci.ResponseCommit/data bytes?)
(s/def :tendermint.abci.ResponseCommit/retain-height int?)
(s/def ::ResponseCommit-spec (s/keys :opt-un [:tendermint.abci.ResponseCommit/data :tendermint.abci.ResponseCommit/retain-height ]))
(def ResponseCommit-defaults {:data (byte-array 0) :retain-height 0 })

(defn cis->ResponseCommit
  "CodedInputStream to ResponseCommit"
  [is]
  (->> (tag-map ResponseCommit-defaults
         (fn [tag index]
             (case index
               2 [:data (serdes.core/cis->Bytes is)]
               3 [:retain-height (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseCommit-record)))

(defn ecis->ResponseCommit
  "Embedded CodedInputStream to ResponseCommit"
  [is]
  (serdes.core/cis->embedded cis->ResponseCommit is))

(defn new-ResponseCommit
  "Creates a new instance from a map, similar to map->ResponseCommit except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseCommit-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseCommit-spec init))))]}
  (-> (merge ResponseCommit-defaults init)
      (map->ResponseCommit-record)))

(defn pb->ResponseCommit
  "Protobuf to ResponseCommit"
  [input]
  (cis->ResponseCommit (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseCommit-meta {:type "tendermint.abci.ResponseCommit" :decoder pb->ResponseCommit})

;-----------------------------------------------------------------------------
; ResponseApplySnapshotChunk
;-----------------------------------------------------------------------------
(defrecord ResponseApplySnapshotChunk-record [result refetch-chunks reject-senders]
  pb/Writer
  (serialize [this os]
    (write-ResponseApplySnapshotChunk-Result 1  {:optimize true} (:result this) os)
    (serdes.complex/write-repeated serdes.core/write-UInt32 2 (:refetch-chunks this) os)
    (serdes.complex/write-repeated serdes.core/write-String 3 (:reject-senders this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.ResponseApplySnapshotChunk"))

(s/def :tendermint.abci.ResponseApplySnapshotChunk/result (s/or :keyword keyword? :int int?))
(s/def :tendermint.abci.ResponseApplySnapshotChunk/refetch-chunks (s/every int?))
(s/def :tendermint.abci.ResponseApplySnapshotChunk/reject-senders (s/every string?))
(s/def ::ResponseApplySnapshotChunk-spec (s/keys :opt-un [:tendermint.abci.ResponseApplySnapshotChunk/result :tendermint.abci.ResponseApplySnapshotChunk/refetch-chunks :tendermint.abci.ResponseApplySnapshotChunk/reject-senders ]))
(def ResponseApplySnapshotChunk-defaults {:result ResponseApplySnapshotChunk-Result-default :refetch-chunks [] :reject-senders [] })

(defn cis->ResponseApplySnapshotChunk
  "CodedInputStream to ResponseApplySnapshotChunk"
  [is]
  (->> (tag-map ResponseApplySnapshotChunk-defaults
         (fn [tag index]
             (case index
               1 [:result (cis->ResponseApplySnapshotChunk-Result is)]
               2 [:refetch-chunks (serdes.complex/cis->packablerepeated tag serdes.core/cis->UInt32 is)]
               3 [:reject-senders (serdes.complex/cis->repeated serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ResponseApplySnapshotChunk-record)))

(defn ecis->ResponseApplySnapshotChunk
  "Embedded CodedInputStream to ResponseApplySnapshotChunk"
  [is]
  (serdes.core/cis->embedded cis->ResponseApplySnapshotChunk is))

(defn new-ResponseApplySnapshotChunk
  "Creates a new instance from a map, similar to map->ResponseApplySnapshotChunk except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ResponseApplySnapshotChunk-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ResponseApplySnapshotChunk-spec init))))]}
  (-> (merge ResponseApplySnapshotChunk-defaults init)
      (map->ResponseApplySnapshotChunk-record)))

(defn pb->ResponseApplySnapshotChunk
  "Protobuf to ResponseApplySnapshotChunk"
  [input]
  (cis->ResponseApplySnapshotChunk (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ResponseApplySnapshotChunk-meta {:type "tendermint.abci.ResponseApplySnapshotChunk" :decoder pb->ResponseApplySnapshotChunk})

;-----------------------------------------------------------------------------
; Validator
;-----------------------------------------------------------------------------
(defrecord Validator-record [address power]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:address this) os)
    (serdes.core/write-Int64 3  {:optimize true} (:power this) os))
  pb/TypeReflection
  (gettype [this]
    "tendermint.abci.Validator"))

(s/def :tendermint.abci.Validator/address bytes?)
(s/def :tendermint.abci.Validator/power int?)
(s/def ::Validator-spec (s/keys :opt-un [:tendermint.abci.Validator/address :tendermint.abci.Validator/power ]))
(def Validator-defaults {:address (byte-array 0) :power 0 })

(defn cis->Validator
  "CodedInputStream to Validator"
  [is]
  (->> (tag-map Validator-defaults
         (fn [tag index]
             (case index
               1 [:address (serdes.core/cis->Bytes is)]
               3 [:power (serdes.core/cis->Int64 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Validator-record)))

(defn ecis->Validator
  "Embedded CodedInputStream to Validator"
  [is]
  (serdes.core/cis->embedded cis->Validator is))

(defn new-Validator
  "Creates a new instance from a map, similar to map->Validator except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Validator-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Validator-spec init))))]}
  (-> (merge Validator-defaults init)
      (map->Validator-record)))

(defn pb->Validator
  "Protobuf to Validator"
  [input]
  (cis->Validator (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Validator-meta {:type "tendermint.abci.Validator" :decoder pb->Validator})

